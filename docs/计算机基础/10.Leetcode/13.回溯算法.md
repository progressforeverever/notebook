---
title: 回溯算法
date: 2024-03-13 14:58:30
permalink: /pages/843628/
categories:
  - 计算机基础
  - Leetcode
tags:
  - 
---
# 回溯

回溯法抽象出来是一个树形结构。

回溯，其实就是回退，然后走另外的几条路。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以**加一些剪枝的操作**，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- **组合问题**：N个数里面按一定规则找出k个数的集合
- **切割问题：一个字符串按一定规则有几种切割方式**
- **子集问题：一个N个数的集合里有多少符合条件的子集 （切割和子集很类似啊）**
- **排列问题：N个数按一定规则全排列，有几种排列方式**
- 棋盘问题：N皇后，解数独等等







**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以**必然是一棵高度有限的树（N叉树）。**



## 回溯模板

列出回溯三部曲。

- **回溯函数模板返回值以及参数**

在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。

**回溯算法中函数返回值一般为void。**

再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，**所以一般是先写逻辑，然后需要什么参数，就填什么参数。**

但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。

回溯函数伪代码如下：

```java
void backtracking(参数)
```

- 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)的时候，就知道遍历树形结构一定要有终止条件。

所以**回溯也有要终止条件。**

**什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。**

所以回溯函数终止条件伪代码如下：

```java
if (终止条件) {
    存放结果;
    return;
}
```

- 回溯搜索的遍历过程

在上面我们提到了，回溯法一般是**在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。**



如图：

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

注意图中，我特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过程伪代码如下：

```java
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

**for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。**

**backtracking这里自己调用自己，实现递归。**

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**这份模板很重要，后面做回溯法的题目都靠它了！**





## [77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

 

本题是回溯法的经典题目。

**直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。**

代码如下：

```cpp
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}
```

输入：n = 100, k = 3 那么就三层for循环，代码如下：

```cpp
int n = 100;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int u = j + 1; u <= n; n++) {
            cout << i << " " << j << " " << u << endl;
        }
    }
}
```

**如果n为100，k为50呢，那就50层for循环，是不是开始窒息**。

**此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！**

咋整？

回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。

那么回溯法怎么暴力搜呢？

上面我们说了**要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题**。

递归来做层叠嵌套（可以理解是开k层for循环），**每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**。

此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。



**需要抽象图形结构来进一步理解。**

**我们在[关于回溯算法，你该了解这些！ (opens new window)](https://programmercarl.com/回溯算法理论基础.html)中说到回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了**。

那么我把组合问题抽象为如下树形结构：

![77.组合](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

可以看出这棵树，**一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。**

第一次取1，**集合变为2，3，4** ，**因为k为2，我们只需要再取一个数就可以了**，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。

**图中可以发现n相当于树的宽度，k相当于树的深度**。

那么如何在这个树上遍历，然后收集到我们要的结果集呢？

**图中每次搜索到了叶子节点，我们就找到了一个结果**。

相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

<br>

**但函数里参数太多影响可读性，所以我定义全局变量了。**

定义全局变量可以减少函数中的参数数量



```c++
vector<vector<int>> result; // 存放符合条件结果的集合
vector<int> path; // 用来存放符合条件单一结果
void backtracking(int n, int k, int startIndex)
```



为什么要有这个startIndex呢？

**startIndex 就是防止出现重复的组合**。

从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。

![77.组合2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195328976.png)

所以**需要startIndex来记录下一层递归，搜索的起始位置。**

- 回溯函数终止条件

什么时候到达所谓的叶子节点了呢？

path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。

如图红色部分：

![77.组合3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195407907.png)

此时用result二维数组，把path保存起来，并终止本层递归。

所以终止条件代码如下：

回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

如此我们才遍历完图中的这棵树。

for循环每次从startIndex开始遍历，然后用path保存取到的节点i。



### 剪枝优化

回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。

在遍历的过程中有如下代码：

```cpp
for (int i = startIndex; i <= n; i++) {
    path.push_back(i);
    backtracking(n, k, i + 1);
    // 这里体现了回溯
    path.pop_back();
}
```

这个遍历的范围是可以剪枝优化的，怎么优化呢？

来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。

这么说有点抽象，如图所示：

![77.组合4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

接下来看一下优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。

举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。

从2开始搜索都是合理的，可以是组合[2, 3, 4]。

这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。

所以优化之后的for循环是：

```java
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```



```java
/**
     * 回溯实际上是一种暴力解法，
     * 之前说了回溯 实际上抽象成一个N叉树，为了优化，就要剪枝
     * 剪枝  剪一些有深度的分支  往往是在for循环中进行的解决
     */
    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){
            path.add(i);
            combineHelper(n, k, i + 1);
            // 这里体现了回溯，把path的最后一个给退出来，然后可以选择其他的
            path.removeLast();
        }
    }
```



## [46. 全排列](https://leetcode.cn/problems/permutations/)



给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```



首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

     * **但排列问题需要一个used数组，标记已经选择的元素**





```java
List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length == 0){
            return result;
        }
        used = new boolean[nums.length];
        backTracking(nums);
        return result;
    }

    public void backTracking(int[] nums){
        // 终止条件：数量到达了
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(used[i]){
                continue;   // 已经被用过了
            }
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums);
		   // 回退，选择其他的
            path.removeLast();
            used[i] = false;
        }
    }
```



**一定要注意把回退的那个步骤写出来**





## [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的

子集

（幂集）。



解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**



```java
	public List<List<Integer>> result = new ArrayList<>();
    public LinkedList<Integer> path = new LinkedList<>();  // removeLast方便一点   注意数据结构的选用

    public List<List<Integer>> subsets(int[] nums) {
         backTracking(nums,0);
         return result;
    }

    // 结果集的存放
    public void backTracking(int[] nums,int startIndex){
        result.add(new ArrayList<>(path));
        //在这里存放结果集
        if(startIndex >= nums.length){
            return;
        }
        //假如在这里存放结果集
        // 因为假如【1，2，3】  然后我们加了3之后，1，2，3  然后进入下一层递归，但此时已经startIndex >= nums.length,上面的判断就过不了了
        //这样就会漏掉最后一个
        for (int i = startIndex; i < nums.length ; i++) {
            path.add(nums[i]);
            backTracking(nums, i+1);
            path.removeLast();
        }
    }
```





## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```



```java
//设置全局列表存储最后的结果
    List<String> list = new ArrayList<>();


    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return list;
        }
        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backTracking(digits, numString, 0);
        return list;
    }


    /**
     * 理解本题后，要解决如下三个问题：
     *
     * 数字和字母如何映射
     * 两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来  然后就会想到用回溯
     * 输入1 * #按键等等异常情况
     */

    //每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild
    StringBuilder temp = new StringBuilder();

    public void backTracking(String digits,String[] numString,int num){
        if(num == digits.length()){
            list.add(temp.toString());
            return;
        }

        String str = numString[digits.charAt(num) - '0'];   //拿numString中的元素
        for (int i = 0; i < str.length(); i++) {
            temp.append(str.charAt(i));
            //c
            backTracking(digits, numString, num + 1);
            //剔除末尾的继续尝试
            temp.deleteCharAt(temp.length() - 1);
        }
    }
```





## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```





题目中的无限制重复被选取，吓得我赶紧想想 出现0 可咋办  得敏感
* 从叶子节点可以清晰看到，**终止只有两种情况，sum大于target和sum等于target。**
* **sum等于target的时候，需要收集结果**
* 单层for循环依然是从startIndex开始，搜索candidates集合。
* 本题元素为可重复选取的。
* backtracking(candidates, target, sum, i); // 关键点:不用i+1了，表示可以重复读取当前的数
* 对于sum已经大于target的情况，**其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回。**
* 其实**如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。**
* 那么可以在for循环的搜索范围上做做文章了。
* 对**总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。**
* 所以**就可以先排一下序**
* 在**求和问题中，排序之后加剪枝是常见的套路！**



```java
public List<List<Integer>> result = new ArrayList<>();
    public List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates); // 先进行排序
        backTracking(candidates,target,0,0);
        return result;
    }

    public void backTracking(int[] candidates, int target, int sum, int index){
        if(sum == target){
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = index; i < candidates.length ; i++) {
            if(sum + candidates[i] > target){
                break;
            }
            path.add(candidates[i]);
            sum = sum + candidates[i];
            backTracking(candidates,target,sum,i);
            sum = sum - candidates[i];
            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素
        }
    }
```





## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 



暴力：我们可以生成所有 2^{2n}然后我们检查每一个是否有效即可。

*  **为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n−1 的序列前加一个 ‘(’ 或 ‘)’**
* 为了检查序列是否有效，我们遍历这个序列，并**使用一个变量 balance 表示左括号的数量减去右括号的数量。**
* 如果在**遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。**



```java
public List<String> generateParenthesis(int n) {
    List<String> combinations = new ArrayList<String>();
    generateAll(new char[2 * n], 0, combinations);
    return combinations;

}


public void generateAll(char[] current, int pos, List<String> result) {
    if (pos == current.length) {
        if (valid(current)) {
            result.add(new String(current));
        }
    } else {
        current[pos] = '(';
        generateAll(current, pos + 1, result);
        current[pos] = ')';
        generateAll(current, pos + 1, result);
    }

}
/**
 * 判断一个char数组是否符合
 * @param current
 * @return
 */
public boolean valid(char[] current){
    int balance = 0;
    for (char c : current) {
        if(c == '('){
            balance++;
        }else {
            balance--;
        }

        // 此时右边已经大于左边了，就已经不符合了
        if(balance < 0){
            return false;
        }
    }
    return balance == 0;
}
```



```java
/**
     * 方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(’‘)’，
     * 而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，
     *
     * 如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。
     * 用 open 表示当前已使用的左括号数量，close 表示当前已使用的右括号数量，max 是括号总数。
     * 这段代码中的回溯方法尝试在每一步中添加左括号和右括号，
     * 同时通过条件判断保证了生成的括号组合的有效性，确保了左右括号的数量平衡，生成所有有效的括号组合。
     * @param n
     * @return
     */
    public List<String> generateParenthesis02(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, "", 0, 0, n);
        return result;
    }

    // 回溯函数
    private void backtrack(List<String> result, String current, int open, int close, int max) {
        // 当字符串长度达到上限，即找到一个有效括号组合，将其添加到结果列表中
        if (current.length() == max * 2) {
            result.add(current);
            return;
        }

        // 如果左括号数量小于最大限制，可以添加左括号
        if (open < max) {
            backtrack(result, current + "(", open + 1, close, max);
        }
        // 如果右括号数量小于左括号数量，可以添加右括号
        if (close < open) {
            backtrack(result, current + ")", open, close + 1, max);
        }
    }
```





## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

 

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

 

**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？





先一行行找  **找到起始点**
* 然后向上找  回退  左 回退 右 回退  下回退
* 有一个成功就继续找  没有的话就回退



设函数 check(i,j,k) 表示判断以网格的 (i,j)位置出发，能否搜索到单词 word[k..]，
* 其中 word[k..] 表示字符串 word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。
* 函数 check(i,j,k) 的执行步骤如下：
* 如果 board[i][j]≠s[k]当前字符不匹配，直接返回 false。
* 如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。
* 否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，（递归）
* 能够搜索到子串 word[k+1..]则返回 true，否则返回 false。
* **为了防止重复遍历相同的位置，需要额外维护一个与 board等大的 visited数组，用于标识每个位置是否被访问过。**
* 每次遍历相邻位置时，需要跳过已经被访问的位置。
* **图论中常用的  visited数组**

```java
public boolean exist(char[][] board, String word) {
    int h = board.length, w = board[0].length;
    boolean[][] visited = new boolean[h][w];

    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            boolean flag = check(board, visited, i, j, word, 0);
            if (flag) {
                return true;
            }
        }
    }
    return false;
}


/**
     *
     * @param board
     * @param visited
     * @param i
     * @param j
     * @param s  目标字符串
     * @param k  第k位
     * @return
     */
    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {

        if (board[i][j] != s.charAt(k)) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        visited[i][j] = true;

        // 经典的图论中的定义方向    用二维数组来定义
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;

        // 每个节点 上下左右都走一次
        for (int[] dir : directions) {
            int newi = i + dir[0], newj = j + dir[1];
            // 确保不越界
            // 回溯带一点图论的知识   有点巧妙
            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {
                if (!visited[newi][newj]) {
                    boolean flag = check(board, visited, newi, newj, s, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }

```



## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 

**回文串**

 返回 `s` 所有可能的分割方案。



 

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

 

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成



```java
public List<List<String>> result;
    public List<String> currentList;

    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        backtrack(s, 0);
        return result;
    }

    private void backtrack(String s, int start) {
        // 如果已经遍历完字符串，则将当前分割情况加入结果列表
        if (start >= s.length()) {
            result.add(new ArrayList<>(currentList));
            return;
        }

        // 从当前位置开始遍历字符串
        for (int end = start; end < s.length(); end++) {
            if (isPalindrome(s, start, end)) { // 如果是回文串
                // 加入当前回文串到当前列表中
                currentList.add(s.substring(start, end + 1));
                // 递归处理下一部分字符串
                backtrack(s, end + 1);
                // 回溯，移除最后一个元素，尝试下一个可能的回文串   回溯
                currentList.remove(currentList.size() - 1);
            }
        }
    }

    /**
     * 双指针判断是不是回文串
     * @param s
     * @param start
     * @param end
     * @return
     */
    private boolean isPalindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start++) != s.charAt(end--)) {
                return false;
            }
        }
        return true;
    }
```







## [51. N 皇后](https://leetcode.cn/problems/n-queens/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

 

**提示：**

- `1 <= n <= 9`





回溯的具体做法是：使用一个数组记录每行放置的皇后的列下标，依次在每一行放置一个皇后。每次新放置的皇后都不能和已经放置的皇后之间有攻击：即新放置的皇后不能和任何一个已经放置的皇后在同一列以及同一条斜线上，并更新数组中的当前行的皇后列下标。当 N个皇后都放置完毕，则找到一个可能的解。当找到一个可能的解之后，将数组转换成表示棋盘状态的列表，并将该棋盘状态的列表加入返回列表。

由于每个皇后必须位于不同列，因此已经放置的皇后所在的列不能放置别的皇后。第一个皇后有 N列可以选择，第二个皇后最多有 N−1 列可以选择，第三个皇后最多有 N−2 列可以选择（如果考虑到不能在同一条斜线上，可能的选择数量更少），因此所有可能的情况不会超过 N!种，遍历这些情况的时间复杂度是 O(N!)

为了降低总时间复杂度，每次放置皇后时需要快速判断每个位置是否可以放置皇后，显然，最理想的情况是在 O(1)的时间内判断该位置所在的列和两条斜线上是否已经有皇后。

以下两种方法分别使用集合和位运算对皇后的放置位置进行判断，都可以在 O(1)的时间内判断一个位置是否可以放置皇后，算法的总时间复杂度都是 O(N!)。

方法一：基于集合的回溯
为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合 

分别记录每一列以及两个方向的每条斜线上是否有皇后。

**列的表示法很直观，一共有 N列，每一列的下标范围从 0 到 N−1，使用列的下标即可明确表示每一列。**

**如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。**

方向一的斜线为**从左上到右下方向**，**同一条斜线上的每个位置满足行下标与列下标之差相等**，例如 (0,0) 和 (3,3)在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。



![fig1](https://assets.leetcode-cn.com/solution-static/51/1.png)

方向二的**斜线为从右上到左下方向，同一条斜线上的每个位置满足行下标与列下标之和相等**，例如 (3,0) 和 (1,2) 在同一条方向二的斜线上。因此使用**行下标与列下标之和即可明确表示每一条方向二的斜线**。



![fig2](https://assets.leetcode-cn.com/solution-static/51/2.png)

每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。



```java
public List<List<String>> solveNQueens(int n) {

        ArrayList<List<String>> result = new ArrayList<>();

        // queens 数组用于存储每一行皇后的列索引，初始化为-1表示未放置皇后
        int[] queens = new int[n];
        Arrays.fill(queens,-1);
        // columns、diagonals1、diagonals2 分别记录列、左上至右下对角线、左下至右上对角线的占用情况
        Set<Integer> columns = new HashSet<Integer>();
        Set<Integer> diagonals1 = new HashSet<Integer>();
        Set<Integer> diagonals2 = new HashSet<Integer>();
        // 回溯算法
        backtracking(result, queens, n, 0, columns, diagonals1, diagonals2);
        return result;
    }

    // 回溯函数，这参数也太多了，果然还是换成全局变量好
    public void backtracking(List<List<String>> result, int[] queens, int n, int row, Set<Integer> columns,
                             Set<Integer> diagonals1, Set<Integer> diagonals2){
        // 若已经放置了所有皇后，生成棋盘并加入结果集
        if(row == n){
            List<String> board = generateBoard(queens, n);
            result.add(board);
        }else {
            // 不满足条件的话，尝试在每一列放置皇后
            for (int i = 0; i < n; i++) {
                // 检查是否可以放置皇后，根据列和两个对角线的占用情况
                if(columns.contains(i) || diagonals1.contains(row - i) || diagonals2.contains(row + i)){
                    continue;
                }
                // 放置皇后并更新占用情况
                queens[row] = i;
                columns.add(i);
                diagonals1.add(row - i);
                diagonals2.add(row + i);
                // 递归到下一行
                backtracking(result, queens, n, row + 1, columns, diagonals1, diagonals2);
                // 回溯，撤销放置的皇后和占用情况
                queens[row] = -1;
                columns.remove(i);
                diagonals1.remove(row - i);
                diagonals2.remove(row + i);
            }
        }

    }

    // 生成棋盘
    private List<String> generateBoard(int[] queens, int n) {
        ArrayList<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row,'.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
```



