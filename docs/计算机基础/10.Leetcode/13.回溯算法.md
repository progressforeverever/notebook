---
title: 回溯算法
date: 2024-03-13 14:58:30
permalink: /pages/843628/
categories:
  - 计算机基础
  - Leetcode
tags:
  - 
---
# 回溯

回溯法抽象出来是一个树形结构。

回溯，其实就是回退，然后走另外的几条路。

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以**加一些剪枝的操作**，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- **组合问题**：N个数里面按一定规则找出k个数的集合
- **切割问题：一个字符串按一定规则有几种切割方式**
- **子集问题：一个N个数的集合里有多少符合条件的子集 （切割和子集很类似啊）**
- **排列问题：N个数按一定规则全排列，有几种排列方式**
- 棋盘问题：N皇后，解数独等等







**回溯法解决的问题都可以抽象为树形结构**，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以**必然是一棵高度有限的树（N叉树）。**



## 回溯模板

列出回溯三部曲。

- **回溯函数模板返回值以及参数**

在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。

**回溯算法中函数返回值一般为void。**

再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，**所以一般是先写逻辑，然后需要什么参数，就填什么参数。**

但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。

回溯函数伪代码如下：

```java
void backtracking(参数)
```

- 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)的时候，就知道遍历树形结构一定要有终止条件。

所以**回溯也有要终止条件。**

**什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。**

所以回溯函数终止条件伪代码如下：

```java
if (终止条件) {
    存放结果;
    return;
}
```

- 回溯搜索的遍历过程

在上面我们提到了，回溯法一般是**在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。**



如图：

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

注意图中，我特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过程伪代码如下：

```java
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

**for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。**

**backtracking这里自己调用自己，实现递归。**

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

**这份模板很重要，后面做回溯法的题目都靠它了！**





## [77. 组合](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

 

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

**示例 2：**

```
输入：n = 1, k = 1
输出：[[1]]
```

 

本题是回溯法的经典题目。

**直接的解法当然是使用for循环，例如示例中k为2，很容易想到 用两个for循环，这样就可以输出 和示例中一样的结果。**

代码如下：

```cpp
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}
```

输入：n = 100, k = 3 那么就三层for循环，代码如下：

```cpp
int n = 100;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int u = j + 1; u <= n; n++) {
            cout << i << " " << j << " " << u << endl;
        }
    }
}
```

**如果n为100，k为50呢，那就50层for循环，是不是开始窒息**。

**此时就会发现虽然想暴力搜索，但是用for循环嵌套连暴力都写不出来！**

咋整？

回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像for循环嵌套k层让人绝望。

那么回溯法怎么暴力搜呢？

上面我们说了**要解决 n为100，k为50的情况，暴力写法需要嵌套50层for循环，那么回溯法就用递归来解决嵌套层数的问题**。

递归来做层叠嵌套（可以理解是开k层for循环），**每一次的递归中嵌套一个for循环，那么递归就可以用于解决多层嵌套循环的问题了**。

此时递归的层数大家应该知道了，例如：n为100，k为50的情况下，就是递归50层。



**需要抽象图形结构来进一步理解。**

**我们在[关于回溯算法，你该了解这些！ (opens new window)](https://programmercarl.com/回溯算法理论基础.html)中说到回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了**。

那么我把组合问题抽象为如下树形结构：

![77.组合](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

可以看出这棵树，**一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。**

第一次取1，**集合变为2，3，4** ，**因为k为2，我们只需要再取一个数就可以了**，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。

**图中可以发现n相当于树的宽度，k相当于树的深度**。

那么如何在这个树上遍历，然后收集到我们要的结果集呢？

**图中每次搜索到了叶子节点，我们就找到了一个结果**。

相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

<br>

**但函数里参数太多影响可读性，所以我定义全局变量了。**

定义全局变量可以减少函数中的参数数量



```c++
vector<vector<int>> result; // 存放符合条件结果的集合
vector<int> path; // 用来存放符合条件单一结果
void backtracking(int n, int k, int startIndex)
```



为什么要有这个startIndex呢？

**startIndex 就是防止出现重复的组合**。

从下图中红线部分可以看出，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。

![77.组合2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195328976.png)

所以**需要startIndex来记录下一层递归，搜索的起始位置。**

- 回溯函数终止条件

什么时候到达所谓的叶子节点了呢？

path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。

如图红色部分：

![77.组合3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195407907.png)

此时用result二维数组，把path保存起来，并终止本层递归。

所以终止条件代码如下：

回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。

![77.组合1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

如此我们才遍历完图中的这棵树。

for循环每次从startIndex开始遍历，然后用path保存取到的节点i。



### 剪枝优化

回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。

在遍历的过程中有如下代码：

```cpp
for (int i = startIndex; i <= n; i++) {
    path.push_back(i);
    backtracking(n, k, i + 1);
    // 这里体现了回溯
    path.pop_back();
}
```

这个遍历的范围是可以剪枝优化的，怎么优化呢？

来举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。

这么说有点抽象，如图所示：

![77.组合4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。

**所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

接下来看一下优化过程如下：

1. 已经选择的元素个数：path.size();
2. 还需要的元素个数为: k - path.size();
3. 在集合n中至多要从该起始位置 : n - (k - path.size()) + 1，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。

举个例子，n = 4，k = 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 = 2。

从2开始搜索都是合理的，可以是组合[2, 3, 4]。

这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。

所以优化之后的for循环是：

```java
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```



```java
/**
     * 回溯实际上是一种暴力解法，
     * 之前说了回溯 实际上抽象成一个N叉树，为了优化，就要剪枝
     * 剪枝  剪一些有深度的分支  往往是在for循环中进行的解决
     */
    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){
            path.add(i);
            combineHelper(n, k, i + 1);
            // 这里体现了回溯，把path的最后一个给退出来，然后可以选择其他的
            path.removeLast();
        }
    }
```



## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```





题目中的无限制重复被选取，吓得我赶紧想想 出现0 可咋办  得敏感

* 从叶子节点可以清晰看到，**终止只有两种情况，sum大于target和sum等于target。**
* **sum等于target的时候，需要收集结果**
* 单层for循环依然是从startIndex开始，搜索candidates集合。
* 本题元素为可重复选取的。
* backtracking(candidates, target, sum, i); // 关键点:不用i+1了，表示可以重复读取当前的数
* 对于sum已经大于target的情况，**其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回。**
* 其实**如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。**
* 那么可以在for循环的搜索范围上做做文章了。
* 对**总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。**
* 所以**就可以先排一下序**
* 在**求和问题中，排序之后加剪枝是常见的套路！**



```java
public List<List<Integer>> result = new ArrayList<>();
    public List<Integer> path = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates); // 先进行排序
        backTracking(candidates,target,0,0);
        return result;
    }

    public void backTracking(int[] candidates, int target, int sum, int index){
        if(sum == target){
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = index; i < candidates.length ; i++) {
            if(sum + candidates[i] > target){
                break;
            }
            path.add(candidates[i]);
            sum = sum + candidates[i];
            backTracking(candidates,target,sum,i);
            sum = sum - candidates[i];
            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素
        }
    }
```









## [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

**示例 2:**

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```



自己写的超时的方法

```java
List<List<Integer>> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    HashSet<List<Integer>> set = new HashSet<>();
    /**
     * 这里的 candidates 中的每个数字在每个组合中只能使用 一次，注意是每个数字，但candidates的数字是可以重复的
     * 一个path中重复是没有问题的，他会一直往后面走，但不同path之间不能包含完全相同的组合
     * 用个set或者map存下标看是否重复使用?
     *
     * 1.先给candidates排个序
     *
     * @param candidates
     * @param target
     * @return
     */
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backTracking(candidates,target,0,0);
        // 将 set 中的元素逐个添加到 result 中
        // 超时啦
        for (List<Integer> list : set) {
            result.add(new ArrayList<>(list));
        }
        return result;
    }


    public void backTracking(int[] candidates,int target,int sum,int startIndex){
        if(sum > target){
            return;
        }

        if(sum == target){
            set.add(new ArrayList<>(path));
            return;
        }

        for (int i = startIndex; i < candidates.length; i++) {
            if(sum + candidates[i] > target){
                break;
            }

            path.add(candidates[i]);
            sum = sum + candidates[i];
            backTracking(candidates,target,sum,i + 1);
            sum = sum - candidates[i];
            path.remove(path.size() - 1);
        }
    }
```



**法二： 使用used数组**

这个去重为什么很难理解呢，**所谓去重，其实就是使用过的元素不能重复选取。** 这么一说好像很简单！

都知道组合问题可以抽象为树形结构，那么**“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过**。没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。

那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）

**强调一下，树层去重的话，需要对数组排序！**

选择过程树形结构如图所示：

![image-20240315105740854](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20240315105740854.png)

可以看到图中，每个节点相对于 [39.组合总和 (opens new window)多加了used数组，

前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

此时for循环里就应该做continue的操作。

其实`candidates[i] == candidates[i - 1]`，**这里是在for循环中，for循环是横向遍历，所以我们要直接跳过，纵向递归的时候可以有重复**

```java
	//正确剔除重复解的办法
  //跳过同一树层使用过的元素
  if ( i > start && candidates[i] == candidates[i - 1] ) {
    continue;
  }
```

这块比较抽象，如图：

![40.组合总和II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)

我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

为什么 used[i - 1] == false 就是同一树层呢，**因为同一树层，used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。**

**而 used[i - 1] == true，说明是进入下一层递归，去下一个数，所以是树枝上，如图所示：**

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png)

**这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！**



```java
// 使用used标记数组
    LinkedList<Integer> path = new LinkedList<>();
    List<List<Integer>> ans = new ArrayList<>();
    boolean[] used;
    int sum = 0;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        used = new boolean[candidates.length];
        // 加标志数组，用来辅助判断同层节点是否已经遍历
        Arrays.fill(used, false);
        // 为了将重复的数字都放到一起，所以先进行排序
        Arrays.sort(candidates);
        backTracking(candidates, target, 0);
        return ans;
    }

    private void backTracking(int[] candidates, int target, int startIndex) {
        if(sum == target){
            return;
        }

        for (int i = startIndex; i < candidates.length; i++) {
            if(sum + candidates[i] > target){
                break;
            }

            // 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过
            if (i > 0 && candidates[i] == candidates[i - 1] && !used[i - 1]) {
                continue;
            }
            
            used[i] = true;
            sum = sum + candidates[i];
            path.add(candidates[i]);
            backTracking(candidates,target,i + 1);
            used[i] = false;
            sum = sum - candidates[i];
            path.removeLast();
        }
    }

```



法三：不使用标记数组

```java
class Solution {
  List<List<Integer>> res = new ArrayList<>();
  LinkedList<Integer> path = new LinkedList<>();
  int sum = 0;
  
  public List<List<Integer>> combinationSum2( int[] candidates, int target ) {
    //为了将重复的数字都放到一起，所以先进行排序
    Arrays.sort( candidates );
    backTracking( candidates, target, 0 );
    return res;
  }
  
  private void backTracking( int[] candidates, int target, int start ) {
    if ( sum == target ) {
      res.add( new ArrayList<>( path ) );
      return;
    }
    for ( int i = start; i < candidates.length && sum + candidates[i] <= target; i++ ) {
      //正确剔除重复解的办法
      //跳过同一树层使用过的元素
      if ( i > start && candidates[i] == candidates[i - 1] ) {
        continue;
      }

      sum += candidates[i];
      path.add( candidates[i] );
      // i+1 代表当前组内元素只选取一次
      backTracking( candidates, target, i + 1 );

      int temp = path.getLast();
      sum -= temp;
      path.removeLast();
    }
  }
}
```



```java
		//正确剔除重复解的办法
      //跳过同一树层使用过的元素
      if ( i > start && candidates[i] == candidates[i - 1] ) {
        continue;
      }
```







## [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

 

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

**示例 2:**

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

**示例 3:**

```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```



一开始  是想 假如k=2两层循环  k=3 就三层循环   k=...   这样就控制不了循环的次数了，**所以就要用到了回溯**
* 然后，举例子   画N叉树
* **k个数  控制N叉树的深度  1——9  控制for循环的宽度**





**startIndex  因为是组合问题，无序 然后要从下一个开始  所以要有个开始的标志**

```java
List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        backtracking(n,0,1,k);
        return result;
    }

    /**
     *
     * @param targetSum 目标和
     * @param sum 现有的和
     * @param startIndex  因为是组合问题，无序 然后要从下一个开始  所以要有个开始的标志
     * @param k
     */
    public void backtracking(int targetSum,int sum,int startIndex,int k){
        // 剪枝  比如说n = 4，那么加入8就已经没有意义了
        if(sum > targetSum){
            return;
        }

        //终止条件
        if(path.size() == k){
            if(sum == targetSum){
                result.add(new ArrayList<>(path));
            }
            return;
        }

        // for循环剪枝
        for (int i = startIndex; i <= 9 - (k - path.size()) + 1 ; i++) {
            path.add(i);
            sum+=i;
            backtracking(targetSum,sum,i+1,k);
            path.removeLast(); // 要pop出去啊
            sum-=i;     // 回溯
        }

    }
```













## [46. 全排列](https://leetcode.cn/problems/permutations/)



给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```



首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

  **但排列问题需要一个used数组，标记已经选择的元素**





```java
List<List<Integer>> result = new ArrayList<>();// 存放符合条件结果的集合
    LinkedList<Integer> path = new LinkedList<>();// 用来存放符合条件结果
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        if(nums.length == 0){
            return result;
        }
        used = new boolean[nums.length];
        backTracking(nums);
        return result;
    }

    public void backTracking(int[] nums){
        // 终止条件：数量到达了
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if(used[i]){
                continue;   // 已经被用过了
            }
            used[i] = true;
            path.add(nums[i]);
            backTracking(nums);
		   // 回退，选择其他的
            path.removeLast();
            used[i] = false;
        }
    }
```



**一定要注意把回退的那个步骤写出来**



## [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)



给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

**示例 2：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```





这里又涉及到去重了。

在[40.组合总和II (opens new window)](https://programmercarl.com/0040.组合总和II.html)、[90.子集II (opens new window)](https://programmercarl.com/0090.子集II.html)我们分别详细讲解了组合问题和子集问题如何去重。

那么排列问题其实也是一样的套路。

**还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**。

我以示例中的 [1,1,2]为例 （为了方便举例，已经排序）抽象为一棵树，去重过程如图：

![47.全排列II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png)

图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。

**一般来说：组合问题和排列问题是在树形结构的叶子节点上收集结果，而子集问题就是取树上所有节点的结果**。



大家发现，去重最为关键的代码为：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
    continue;
}
```

**如果改成 `used[i - 1] == true`， 也是正确的!**，去重代码如下：

```cpp
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用`used[i - 1] == false`，如果要对树枝前一位去重用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**

这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png)

**大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索。**



这里可能大家又有疑惑，既然 `used[i - 1] == false`也行而`used[i - 1] == true`也行，那为什么还要写这个条件呢？

**直接这样写 不就完事了？**

```cpp
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

其实并不行，一定要加上 `used[i - 1] == false`或者`used[i - 1] == true`，**因为 used[i - 1] 要一直是 true 或者一直是false 才可以，而不是 一会是true 一会又是false。 所以这个条件要写上。**

是不是豁然开朗了！！

```java

    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    /**
     * 这个要怎么去重啊
     * 单层是可以重复选的
     * 但后继前驱关系好像有点难搞啊
     * 还要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了。
     * @param nums
     * @return
     */
    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used,false);
        Arrays.sort(nums);
        backTracking(nums,used);
        return result;
    }
    public void backTracking(int[] nums,boolean[] used){
        if(path.size() == nums.length){
            result.add(new ArrayList<>(path));
            return;
        }

        for (int i = 0; i < nums.length; i++) {

            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false){
                continue;
            }

            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if(used[i] == false){
                used[i] = true;
                path.add(nums[i]);
                backTracking(nums,used);
                used[i] = false;
                path.remove(path.size() - 1); // 回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
            }
        }
    }
```

















## [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的

子集

（幂集）。



解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**



```java
	public List<List<Integer>> result = new ArrayList<>();
    public LinkedList<Integer> path = new LinkedList<>();  // removeLast方便一点   注意数据结构的选用

    public List<List<Integer>> subsets(int[] nums) {
         backTracking(nums,0);
         return result;
    }

    // 结果集的存放
    public void backTracking(int[] nums,int startIndex){
        result.add(new ArrayList<>(path));
        //在这里存放结果集
        if(startIndex >= nums.length){
            return;
        }
        //假如在这里存放结果集
        // 因为假如【1，2，3】  然后我们加了3之后，1，2，3  然后进入下一层递归，但此时已经startIndex >= nums.length,上面的判断就过不了了
        //这样就会漏掉最后一个
        for (int i = startIndex; i < nums.length ; i++) {
            path.add(nums[i]);
            backTracking(nums, i+1);
            path.removeLast();
        }
    }
```





## [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 

子集

（幂集）。



解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

 

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`



用示例中的[1, 2, 2] 来举例，如图所示： （**注意去重需要先对集合排序**）

![90.子集II](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124195411977.png)

从图中可以看出，同一树层上重复取2 就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！



```java

    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<Integer>();

    /**
     * 回溯算法中的去重问题
     * @param nums
     * @return
     */
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        if(nums == null || nums.length == 0){
            return result;
        }
        Arrays.sort(nums);
        backTracking(nums,0);
        return result;
    }

    public void backTracking(int[] nums,int startIndex){

        result.add(new ArrayList<>(path));
        for (int i = startIndex; i < nums.length; i++) {
            // 树层之间去重
            if(i > startIndex && nums[i] == nums[i - 1]){
                continue;
            }
            path.add(nums[i]);
            // 这里用startIndex 和 i 是不一样的
            backTracking(nums,i + 1);
            path.removeLast();
        }
    }
```





## [491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

**示例 2：**

```
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```

 

**提示：**

- `1 <= nums.length <= 15`
- `-100 <= nums[i] <= 100`



```java
List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        if(nums == null || nums.length == 0){
            return result;
        }
        backTracking(nums,0);
        return result;
    }

    public void backTracking(int[] nums,int startIndex){

        // 确定终止条件 我感觉这里有问题?
        if(path.size() >= 2){
            result.add(new ArrayList<>(path));
//            return;    这里不用return 因为要继续取，
        }

        HashSet<Integer> set = new HashSet<>();
        // 对于那种可以跳过的，如何处理?  没事，会回溯出去的
        for (int i = startIndex; i < nums.length; i++) {

            // 不满足升序 或者已经有了
            if(!path.isEmpty() && path.getLast() > nums[i] || set.contains(nums[i])){
                continue;
            }
            set.add(nums[i]);
            path.add(nums[i]);
            backTracking(nums,i + 1);
            path.remove(path.size() - 1);
            // 这里set为什么不用出来呢?
            // 这里的set是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！
        }
    }
```





## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```



从示例上来说，输入"23"，最直接的想法就是两层for循环遍历了吧，正好把组合的情况都输出了。

**如果输入"233"呢，那么就三层for循环，如果"2333"呢，就四层for循环.......**

大家应该感觉出和77.组合 (opens new window)遇到的一样的问题，就是这for循环的层数如何写出来，此时又是回溯法登场的时候了。

理解本题后，要解决如下三个问题：

1. 数字和字母如何映射
2. 两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来
3. 输入1 * #按键等等异常情况





```java
//设置全局列表存储最后的结果
    List<String> list = new ArrayList<>();


    public List<String> letterCombinations(String digits) {
        if (digits == null || digits.length() == 0) {
            return list;
        }
        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串""
        String[] numString = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        backTracking(digits, numString, 0);
        return list;
    }


    /**
     * 理解本题后，要解决如下三个问题：
     *
     * 数字和字母如何映射
     * 两个字母就两个for循环，三个字符我就三个for循环，以此类推，然后发现代码根本写不出来  然后就会想到用回溯
     * 输入1 * #按键等等异常情况
     */

    //每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild
    StringBuilder temp = new StringBuilder();

    public void backTracking(String digits,String[] numString,int num){
        if(num == digits.length()){
            list.add(temp.toString());
            return;
        }

        String str = numString[digits.charAt(num) - '0'];   //拿numString中的元素
        for (int i = 0; i < str.length(); i++) {
            temp.append(str.charAt(i));
            //c
            backTracking(digits, numString, num + 1);
            //剔除末尾的继续尝试
            temp.deleteCharAt(temp.length() - 1);
        }
    }
```









## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```

 



暴力：我们可以生成所有 2^{2n}然后我们检查每一个是否有效即可。

*  **为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n−1 的序列前加一个 ‘(’ 或 ‘)’**
* 为了检查序列是否有效，我们遍历这个序列，并**使用一个变量 balance 表示左括号的数量减去右括号的数量。**
* 如果在**遍历过程中 balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。**



```java
public List<String> generateParenthesis(int n) {
    List<String> combinations = new ArrayList<String>();
    generateAll(new char[2 * n], 0, combinations);
    return combinations;

}


public void generateAll(char[] current, int pos, List<String> result) {
    if (pos == current.length) {
        if (valid(current)) {
            result.add(new String(current));
        }
    } else {
        current[pos] = '(';
        generateAll(current, pos + 1, result);
        current[pos] = ')';
        generateAll(current, pos + 1, result);
    }

}
/**
 * 判断一个char数组是否符合
 * @param current
 * @return
 */
public boolean valid(char[] current){
    int balance = 0;
    for (char c : current) {
        if(c == '('){
            balance++;
        }else {
            balance--;
        }

        // 此时右边已经大于左边了，就已经不符合了
        if(balance < 0){
            return false;
        }
    }
    return balance == 0;
}
```



```java
/**
     * 方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(’‘)’，
     * 而不是像 方法一 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，
     *
     * 如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。
     * 用 open 表示当前已使用的左括号数量，close 表示当前已使用的右括号数量，max 是括号总数。
     * 这段代码中的回溯方法尝试在每一步中添加左括号和右括号，
     * 同时通过条件判断保证了生成的括号组合的有效性，确保了左右括号的数量平衡，生成所有有效的括号组合。
     * @param n
     * @return
     */
    public List<String> generateParenthesis02(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, "", 0, 0, n);
        return result;
    }

    // 回溯函数
    private void backtrack(List<String> result, String current, int open, int close, int max) {
        // 当字符串长度达到上限，即找到一个有效括号组合，将其添加到结果列表中
        if (current.length() == max * 2) {
            result.add(current);
            return;
        }

        // 如果左括号数量小于最大限制，可以添加左括号
        if (open < max) {
            backtrack(result, current + "(", open + 1, close, max);
        }
        // 如果右括号数量小于左括号数量，可以添加右括号
        if (close < open) {
            backtrack(result, current + ")", open, close + 1, max);
        }
    }
```





## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

 

**提示：**

- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

 

**进阶：**你可以使用搜索剪枝的技术来优化解决方案，使其在 `board` 更大的情况下可以更快解决问题？





先一行行找  **找到起始点**
* 然后向上找  回退  左 回退 右 回退  下回退
* 有一个成功就继续找  没有的话就回退



设函数 check(i,j,k) 表示判断以网格的 (i,j)位置出发，能否搜索到单词 word[k..]，
* 其中 word[k..] 表示字符串 word 从第 k 个字符开始的后缀子串。如果能搜索到，则返回 true，反之返回 false。
* 函数 check(i,j,k) 的执行步骤如下：
* 如果 board[i][j]≠s[k]当前字符不匹配，直接返回 false。
* 如果当前已经访问到字符串的末尾，且对应字符依然匹配，此时直接返回 true。
* 否则，遍历当前位置的所有相邻位置。如果从某个相邻位置出发，（递归）
* 能够搜索到子串 word[k+1..]则返回 true，否则返回 false。
* **为了防止重复遍历相同的位置，需要额外维护一个与 board等大的 visited数组，用于标识每个位置是否被访问过。**
* 每次遍历相邻位置时，需要跳过已经被访问的位置。
* **图论中常用的  visited数组**

```java
public boolean exist(char[][] board, String word) {
    int h = board.length, w = board[0].length;
    boolean[][] visited = new boolean[h][w];

    for (int i = 0; i < h; i++) {
        for (int j = 0; j < w; j++) {
            boolean flag = check(board, visited, i, j, word, 0);
            if (flag) {
                return true;
            }
        }
    }
    return false;
}


/**
     *
     * @param board
     * @param visited
     * @param i
     * @param j
     * @param s  目标字符串
     * @param k  第k位
     * @return
     */
    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) {

        if (board[i][j] != s.charAt(k)) {
            return false;
        } else if (k == s.length() - 1) {
            return true;
        }
        visited[i][j] = true;

        // 经典的图论中的定义方向    用二维数组来定义
        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        boolean result = false;

        // 每个节点 上下左右都走一次
        for (int[] dir : directions) {
            int newi = i + dir[0], newj = j + dir[1];
            // 确保不越界
            // 回溯带一点图论的知识   有点巧妙
            if (newi >= 0 && newi < board.length && newj >= 0 && newj < board[0].length) {
                if (!visited[newi][newj]) {
                    boolean flag = check(board, visited, newi, newj, s, k + 1);
                    if (flag) {
                        result = true;
                        break;
                    }
                }
            }
        }
        visited[i][j] = false;
        return result;
    }

```



## [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 

**回文串**

 返回 `s` 所有可能的分割方案。



 

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

**示例 2：**

```
输入：s = "a"
输出：[["a"]]
```

 

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成



我们来分析一下切割，**其实切割问题类似组合问题**。

例如对于字符串abcdef：

- 组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中再选取第三个.....。
- 切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段.....。

感受出来了不？

所以切割问题，也可以抽象为一棵树形结构，如图：

![131.分割回文串](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。

此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。

从树形结构的图中可以看出：**切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。**

**那么在代码里什么是切割线呢？**

在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，**这个startIndex就是切割线。**



```java
public List<List<String>> result;
    public List<String> currentList;

    public List<List<String>> partition(String s) {
        List<List<String>> result = new ArrayList<>();
        backtrack(s, 0);
        return result;
    }

    private void backtrack(String s, int start) {
        // 如果已经遍历完字符串，则将当前分割情况加入结果列表
        if (start >= s.length()) {
            result.add(new ArrayList<>(currentList));
            return;
        }

        // 从当前位置开始遍历字符串
        for (int end = start; end < s.length(); end++) {
            if (isPalindrome(s, start, end)) { // 如果是回文串
                // 加入当前回文串到当前列表中
                currentList.add(s.substring(start, end + 1));
                // 递归处理下一部分字符串
                backtrack(s, end + 1);
                // 回溯，移除最后一个元素，尝试下一个可能的回文串   回溯
                currentList.remove(currentList.size() - 1);
            }
        }
    }

    /**
     * 双指针判断是不是回文串
     * @param s
     * @param start
     * @param end
     * @return
     */
    private boolean isPalindrome(String s, int start, int end) {
        while (start < end) {
            if (s.charAt(start++) != s.charAt(end--)) {
                return false;
            }
        }
        return true;
    }
```





## [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)



**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

**提示：**

- `1 <= s.length <= 20`
- `s` 仅由数字组成





这道题目相信大家刚看的时候，应该会一脸茫然。

其实只要**意识到这是切割问题 （只不过这里是用 . 进行切割）**，**切割问题就可以使用回溯搜索法把所有可能性搜出来**，和刚做过的[131.分割回文串 (opens new window)](https://programmercarl.com/0131.分割回文串.html)就十分类似了。

切割问题可以抽象为树型结构，如图：

![93.复原IP地址](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png)



- 递归参数：startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。本题我们还需要一个变量pointNum，记录添加逗点的数量。
- 递归终止条件：本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。然后验证一下第四段是否合法，如果合法就加入到结果集里
- 单层搜索的逻辑

在[131.分割回文串 (opens new window)](https://programmercarl.com/0131.分割回文串.html)中已经讲过在循环遍历中如何截取子串。

在`for (int i = startIndex; i < s.size(); i++)`循环中 [startIndex, i] 这个区间就是截取的子串，需要判断这个子串是否合法。

**如果合法就在字符串后面加上符号`.`表示已经分割。 直接在原字符串上操作即可**

如果不合法就结束本层循环，如图中剪掉的分支：

![93.复原IP地址](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310132314109.png)

然后就是递归和回溯的过程：

递归调用时，**下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符`.`），同时记录分割符的数量pointNum 要 +1。**

**回溯的时候，就将刚刚加入的分隔符`.` 删掉就可以了，pointNum也要-1。**

**判断子串是否合法**

最后就是在写一个判断段位是否是有效段位了。

主要考虑到如下三点：

- 段位以0为开头的数字不合法
- 段位里有非正整数字符不合法
- 段位如果大于255了不合法



```java
List<String> result = new ArrayList<>();

    /**
     * 感觉通过s的长度  %4 算出 比如说一个两位 两个三位这样子 利用抽屉原理
     *
     * 每个整数位于 0 到 255 之间组成，且不能含有前导 0
     *
     * 没什么思路啊
     * @param s
     * @return
     */
    public List<String> restoreIpAddresses(String s) {
        if(s.length() > 12){
            return result;
        }

        backTracking(s,0,0);
        return result;
    }

    public void backTracking(String s,int startIndex,int pointNum){
        if(pointNum == 3){
            if(isValid(s,startIndex,s.length() - 1)){
                result.add(s);
            }
            return;
        }

        for (int i = startIndex; i < s.length(); i++) {
            // 如果一部分满足切割条件
            if(isValid(s,startIndex,i)){
                s = s.substring(0,i + 1) + '.' + s.substring(i + 1);
                pointNum++;
                backTracking(s,i + 2,pointNum);
                pointNum--;
                s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点
            }else {
                break;
            }
        }
    }


    /**
     * 判断字符串s在[start,end]区间是否合法
     * 段位以0为开头的数字不合法
     * 段位里有非正整数字符不合法
     * 段位如果大于255了不合法
     * @param s
     * @param start
     * @param end
     * @return
     */
    public boolean isValid(String s,int start,int end){
        if(start > end){
            return false;
        }

        // 0开头的数字不合法
        if (s.charAt(start) == '0' && start != end){
            return false;
        }

        int num = 0;
        // 注意<=  要右闭
        for (int i = start; i <= end; i++) {
            // 遇到⾮数字字符不合法
            if(s.charAt(i) > '9' || s.charAt(i) < '0'){
                return false;
            }
            num = num * 10 + (s.charAt(i) - '0');    // s.charAt(i) - '0'  当前位的数字 - '0'  ASCII中的数字都是连在一起的，ASCII码连续
            if(num > 255){
                return false;
            }
        }
        return true;
    }
```





## [51. N 皇后](https://leetcode.cn/problems/n-queens/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

 

**提示：**

- `1 <= n <= 9`





回溯的具体做法是：使用一个数组记录每行放置的皇后的列下标，依次在每一行放置一个皇后。每次新放置的皇后都不能和已经放置的皇后之间有攻击：即新放置的皇后不能和任何一个已经放置的皇后在同一列以及同一条斜线上，并更新数组中的当前行的皇后列下标。当 N个皇后都放置完毕，则找到一个可能的解。当找到一个可能的解之后，将数组转换成表示棋盘状态的列表，并将该棋盘状态的列表加入返回列表。

由于每个皇后必须位于不同列，因此已经放置的皇后所在的列不能放置别的皇后。第一个皇后有 N列可以选择，第二个皇后最多有 N−1 列可以选择，第三个皇后最多有 N−2 列可以选择（如果考虑到不能在同一条斜线上，可能的选择数量更少），因此所有可能的情况不会超过 N!种，遍历这些情况的时间复杂度是 O(N!)

为了降低总时间复杂度，每次放置皇后时需要快速判断每个位置是否可以放置皇后，显然，最理想的情况是在 O(1)的时间内判断该位置所在的列和两条斜线上是否已经有皇后。

以下两种方法分别使用集合和位运算对皇后的放置位置进行判断，都可以在 O(1)的时间内判断一个位置是否可以放置皇后，算法的总时间复杂度都是 O(N!)。

方法一：基于集合的回溯
为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合 

分别记录每一列以及两个方向的每条斜线上是否有皇后。

**列的表示法很直观，一共有 N列，每一列的下标范围从 0 到 N−1，使用列的下标即可明确表示每一列。**

**如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。**

方向一的斜线为**从左上到右下方向**，**同一条斜线上的每个位置满足行下标与列下标之差相等**，例如 (0,0) 和 (3,3)在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。



![fig1](https://assets.leetcode-cn.com/solution-static/51/1.png)

方向二的**斜线为从右上到左下方向，同一条斜线上的每个位置满足行下标与列下标之和相等**，例如 (3,0) 和 (1,2) 在同一条方向二的斜线上。因此使用**行下标与列下标之和即可明确表示每一条方向二的斜线**。



![fig2](https://assets.leetcode-cn.com/solution-static/51/2.png)

每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。



```java
public List<List<String>> solveNQueens(int n) {

        ArrayList<List<String>> result = new ArrayList<>();

        // queens 数组用于存储每一行皇后的列索引，初始化为-1表示未放置皇后
        int[] queens = new int[n];
        Arrays.fill(queens,-1);
        // columns、diagonals1、diagonals2 分别记录列、左上至右下对角线、左下至右上对角线的占用情况
        Set<Integer> columns = new HashSet<Integer>();
        Set<Integer> diagonals1 = new HashSet<Integer>();
        Set<Integer> diagonals2 = new HashSet<Integer>();
        // 回溯算法
        backtracking(result, queens, n, 0, columns, diagonals1, diagonals2);
        return result;
    }

    // 回溯函数，这参数也太多了，果然还是换成全局变量好
    public void backtracking(List<List<String>> result, int[] queens, int n, int row, Set<Integer> columns,
                             Set<Integer> diagonals1, Set<Integer> diagonals2){
        // 若已经放置了所有皇后，生成棋盘并加入结果集
        if(row == n){
            List<String> board = generateBoard(queens, n);
            result.add(board);
        }else {
            // 不满足条件的话，尝试在每一列放置皇后
            for (int i = 0; i < n; i++) {
                // 检查是否可以放置皇后，根据列和两个对角线的占用情况
                if(columns.contains(i) || diagonals1.contains(row - i) || diagonals2.contains(row + i)){
                    continue;
                }
                // 放置皇后并更新占用情况
                queens[row] = i;
                columns.add(i);
                diagonals1.add(row - i);
                diagonals2.add(row + i);
                // 递归到下一行
                backtracking(result, queens, n, row + 1, columns, diagonals1, diagonals2);
                // 回溯，撤销放置的皇后和占用情况
                queens[row] = -1;
                columns.remove(i);
                diagonals1.remove(row - i);
                diagonals2.remove(row + i);
            }
        }

    }

    // 生成棋盘
    private List<String> generateBoard(int[] queens, int n) {
        ArrayList<String> board = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            char[] row = new char[n];
            Arrays.fill(row,'.');
            row[queens[i]] = 'Q';
            board.add(new String(row));
        }
        return board;
    }
```









都知道n皇后问题是回溯算法解决的经典问题，但是用回溯解决多了组合、切割、子集、排列问题之后，遇到这种二维矩阵还会有点不知所措。

首先来看一下皇后们的约束条件：

1. 不能同行
2. 不能同列
3. 不能同斜线

确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。

下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：

![image-20240316165845660](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20240316184107881.png)

从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。

那么我们用皇后们的约束条件，来回溯搜索这棵树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。



- 递归函数参数

我依然是定义全局变量二维数组result来记录最终结果。

**参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。**

- 递归终止条件

在如下树形结构中： ![51.N皇后](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303-20230310122134167.jpg)

可以看出，当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。

- 单层搜索的逻辑

**递归深度就是row控制棋盘的行**，**每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。**

**每次都是要从新的一行的起始位置开始搜，所以都是从0开始**



```java
for (int col = 0; col < n; col++) {
    if (isValid(row, col, chessboard, n)) { // 验证合法就可以放
        chessboard[row][col] = 'Q'; // 放置皇后
        backtracking(n, row + 1, chessboard);
        chessboard[row][col] = '.'; // 回溯，撤销皇后
    }
}
```





```java
List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessboard = new char[n][n];
        for (char[] c : chessboard) {
            Arrays.fill(c, '.');
        }
        backTrack(n, 0, chessboard);
        return res;
    }


    public void backTrack(int n, int row, char[][] chessboard) {
        if (row == n) {
            res.add(Array2List(chessboard));
            return;
        }

        for (int col = 0;col < n; ++col) {
            if (isValid (row, col, n, chessboard)) {
                chessboard[row][col] = 'Q';
                backTrack(n, row+1, chessboard);
                chessboard[row][col] = '.';
            }
        }

    }


    public List Array2List(char[][] chessboard) {
        List<String> list = new ArrayList<>();

        for (char[] c : chessboard) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }


    public boolean isValid(int row, int col, int n, char[][] chessboard) {
        // 检查列
        for (int i=0; i<row; ++i) { // 相当于剪枝
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查45度对角线   因为是从上往下来的，所以只需要往上面走即可  然后 45°和135°  控制i、j即可
        for (int i=row-1, j=col-1; i>=0 && j>=0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查135度对角线
        for (int i=row-1, j=col+1; i>=0 && j<=n-1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
```





## [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```

 

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字或者 `'.'`
- 题目数据 **保证** 输入数独仅有一个解





棋盘搜索问题可以使用回溯法暴力搜索，只不过这次我们要做的是**二维递归**。

怎么做二维递归呢？

大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：[77.组合（组合问题） (opens new window)](https://programmercarl.com/0077.组合.html)，[131.分割回文串（分割问题） (opens new window)](https://programmercarl.com/0131.分割回文串.html)，[78.子集（子集问题） (opens new window)](https://programmercarl.com/0078.子集.html)，[46.全排列（排列问题） (opens new window)](https://programmercarl.com/0046.全排列.html)，以及[51.N皇后（N皇后问题） (opens new window)](https://programmercarl.com/0051.N皇后.html)，**其实这些题目都是一维递归。**

[N皇后问题 (opens new window)](https://programmercarl.com/0051.N皇后.html)是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。

本题就不一样了，**本题中棋盘的每一个位置都要放一个数字（而N皇后是一行只放一个皇后），并检查数字是否合法，解数独的树形结构要比N皇后更宽更深**。

因为这个树形结构太大了，我抽取一部分，如图所示：



![image-20240316171252059](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20240316165845660.png)



- 递归函数以及参数

**递归函数的返回值需要是bool类型，为什么呢？**

因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。

代码如下：

```cpp
bool backtracking(vector<vector<char>>& board)
```

- 递归终止条件

本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

**不用终止条件会不会死循环？**

递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！

**那么有没有永远填不满的情况呢？**

这个问题我在递归单层搜索逻辑里再来讲！

- 递归单层搜索逻辑

![37.解数独](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790-20230310131822254.png)

在树形图中可以看出我们需要的是一个二维的递归（也就是两个for循环嵌套着递归）

**一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！**





```java
class Solution {
    public void solveSudoku(char[][] board) {
        solveSudokuHelper(board);
    }

    private boolean solveSudokuHelper(char[][] board){
        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，
        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」
        for (int i = 0; i < 9; i++){ // 遍历行
            for (int j = 0; j < 9; j++){ // 遍历列
                if (board[i][j] != '.'){ // 跳过原始数字
                    continue;
                }
                for (char k = '1'; k <= '9'; k++){ // (i, j) 这个位置放k是否合适
                    if (isValidSudoku(i, j, k, board)){
                        board[i][j] = k;
                        if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，那么就返回false
                return false;
                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！
                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」
            }
        }
        // 遍历完没有返回false，说明找到了合适棋盘位置了
        return true;
    }

    /**
     * 判断棋盘是否合法有如下三个维度:
     *     同行是否重复
     *     同列是否重复
     *     9宫格里是否重复
     */
    private boolean isValidSudoku(int row, int col, char val, char[][] board){
        // 同行是否重复
        for (int i = 0; i < 9; i++){
            if (board[row][i] == val){
                return false;
            }
        }
        // 同列是否重复
        for (int j = 0; j < 9; j++){
            if (board[j][col] == val){
                return false;
            }
        }
        // 9宫格里是否重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for (int i = startRow; i < startRow + 3; i++){
            for (int j = startCol; j < startCol + 3; j++){
                if (board[i][j] == val){
                    return false;
                }
            }
        }
        return true;
    }
}
```











## 小总结



可以直观的看出其搜索的过程：**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**，

**剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了**。

**在for循环上做剪枝操作是回溯法剪枝的常见套路！** 后面的题目还会经常用到。

**本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？**

我举过例子，**如果是一个集合来求组合的话，就需要startIndex**，例如：[回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.组合.html)，[回溯算法：求组合总和！ (opens new window)](https://programmercarl.com/0216.组合总和III.html)。

如果是**多个集合取组合，各个集合之间相互不影响，那么就不用startIndex**，例如：[回溯算法：电话号码的字母组合(opens new window)](https://programmercarl.com/0017.电话号码的字母组合.html)

**注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路**。





在[回溯算法：求组合总和（三） (opens new window)](https://programmercarl.com/0040.组合总和II.html)中集合元素会有重复，但要求解集不能包含重复的组合。

**所以难就难在去重问题上了**。



**arl自创了两个词汇，“树枝去重”和“树层去重”**。

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因**。

![image-20240316184107881](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20240316171252059.png)

我在图中将used的变化用橘黄色标注上，**可以看出在candidates[i] == candidates[i - 1]相同的情况下：**

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

**这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！**

对于去重，其实排列和子集问题也是一样的道理



在[回溯算法：分割回文串 (opens new window)](https://programmercarl.com/0131.分割回文串.html)中，我们开始讲解切割问题，虽然最后代码看起来好像是一道模板题，但是从分析到学会套用这个模板，是比较难的。

我列出如下几个难点：

- 切割问题其实类似组合问题
- **如何模拟那些切割线**
- 切割问题中递归如何终止
- 在递归循环中如何截取子串
- 如何判断回文

如果想到了**用求解组合问题的思路来解决 切割问题本题就成功一大半了**，接下来就可以对着模板照葫芦画瓢。

**但后序如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了**。

所以本题应该是一个道hard题目了。

除了这些难点，**本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1**。





**但子集问题一定要排序，为什么呢？**

我用没有排序的集合{2,1,2,2}来举个例子画一个图，如下：

![90.子集II2](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111316440479.png)

**相信这个图胜过千言万语的解释了**。





[回溯算法：排列问题！ (opens new window)](https://programmercarl.com/0046.全排列.html)又不一样了。

排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。

可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

如图：

![46.全排列](https://code-thinking-1253855093.file.myqcloud.com/pics/20201112170304979.png)

**大家此时可以感受出排列问题的不同：**

- **每层都是从0开始搜索而不是startIndex**
- **需要used数组记录path里都放了哪些元素了**

