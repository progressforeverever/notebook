---
title: 动态规划
date: 2024-03-06 09:43:43
permalink: /pages/6a4ab1/
categories:
  - 计算机基础
  - Leetcode
tags:
  - 
---
# 动态规划

**动态规划（Dynamic Programming，简称DP）**是一种常用的算法思想，用于**解决各种优化问题，通常涉及最大化或最小化某种目标**。动态规划的核心思想是**将复杂问题分解为更小的子问题，解决这些子问题，并根据子问题的解来构建原始问题的解。**

动态规划通常用于解决那些具有重叠子问题和最优子结构性质的问题。最优子结构性质意味着问题的最优解可以由其子问题的最优解构建而成，而重叠子问题表示在解决问题时，我们会多次计算相同的子问题。

下面通过一个示例来说明动态规划的概念：

**示例：斐波那契数列**

斐波那契数列是一个经典的动态规划问题，它定义如下：

```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2) (n > 1)
```

这个问题的目标是计算第n个斐波那契数。在这里，我们可以使用动态规划来解决它。

动态规划解决该问题的一般步骤如下：

DP 数组  以及下标含义

初始化

递推公式（就固定那几种）

遍历顺序

打印DP数组，检查



1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**



发出这样的问题之前，其实可以自己先思考这三个问题：

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？



1. **定义状态**：首先，定义问题的状态。在斐波那契数列问题中，状态可以表示为F(n)，表示第n个斐波那契数。

2. **确定状态转移方程**：接下来，确定状态之间的关系，即状态转移方程。在斐波那契数列问题中，状态转移方程已经在定义中给出，即F(n) = F(n-1) + F(n-2)。

3. **初始化**：初始化边界状态，通常是最简单的状态。在斐波那契数列问题中，我们初始化F(0)和F(1)。

4. 自底向上计算：使用状态转移方程自底向上计算状态F(n)，从边界状态开始逐步计算，直到达到所需的状态F(n)。

5. 返回答案：最终，返回所需状态的值，这就是问题的答案。

动态规划的优势在于它避免了重复计算，通过存储子问题的解，可以有效地解决复杂问题。在上述斐波那契数列问题中，动态规划允许我们以线性时间复杂度解决问题，而不需要递归计算重复的子问题。

这只是动态规划的基本概念，实际上，动态规划可以应用于各种复杂问题，包括最短路径、编辑距离、背包问题、子序列问题等等。







## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



**子数组**

是数组中的一个连续部分。



 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```



法一： 连续子数组的和  首先想到的是前缀和

构建前缀和数组，然后遍历前缀和数组相减，取最大值   时间复杂度O（n^2）

然后就超时了🤣

```java
public int maxSubArray02(int[] nums) {
        int length = nums.length;
        int[] preSum = new int[length + 1];

        // 构建前缀和数组
        preSum[0] = 0;
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }

        int result = Integer.MIN_VALUE;
        // 这里之前写了 i = 1，后面 j = i + 1,i凭啥等于1啊，那后面不就有可能超了嘛
        for (int i = 0; i < preSum.length; i++) {
            for (int j = i + 1; j < preSum.length; j++) {
                result = Math.max(result,preSum[j] - preSum[i]);
            }
        }
        return result;
    }
```





法二：动态规划

我们**用 f(i)代表以第 i个数结尾的「连续子数组的最大和」**，那么很显然我们要求的答案就是：**max{f(i)}**
* **f(i)=max{ f(i−1) + nums[i], nums[i] }**   这里看用一个数组来记录就可以
* 优化：small tricks
* 不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f数组来保存 f(i) 的值，用一个循环求出所有 f(i)
* 考虑到 f(i) 只和 f(i−1) 相关，于是我们**可以只用一个变量  来维护对于当前 f(i) 的 f(i−1)的值是多少，**
* 从而让空间复杂度降低到 O(1)，**这有点类似「滚动数组」的思想。**

```java
public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int currentMax = nums[0]; // 以当前元素结尾的最大子数组和
        int globalMax = nums[0]; // 整个数组中的最大子数组和

        for (int i = 1; i < nums.length; i++) {
            // 计算以当前元素结尾的最大子数组和，或者从当前元素开始一个新的子数组
            currentMax = Math.max(currentMax + nums[i], nums[i]);
            // 更新整个数组中的最大子数组和
            globalMax = Math.max(globalMax, currentMax);
        }

        return globalMax;
    }
```















