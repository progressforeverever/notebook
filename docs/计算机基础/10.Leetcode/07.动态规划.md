---
title: 动态规划
date: 2024-03-06 09:43:43
permalink: /pages/6a4ab1/
categories:
  - 计算机基础
  - Leetcode
tags:
  - 
---
# 动态规划

**动态规划（Dynamic Programming，简称DP）**是一种常用的算法思想，用于**解决各种优化问题，通常涉及最大化或最小化某种目标**。动态规划的核心思想是**将复杂问题分解为更小的子问题，解决这些子问题，并根据子问题的解来构建原始问题的解。**

动态规划通常用于解决那些具有**重叠子问题**和**最优子结构性质的问题**。**最优子结构性质意味着问题的最优解可以由其子问题的最优解构建而成，而重叠子问题表示在解决问题时，我们会多次计算相同的子问题。**

下面通过一个示例来说明动态规划的概念：

**示例：斐波那契数列**

斐波那契数列是一个经典的动态规划问题，它定义如下：

```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2) (n > 1)
```

这个问题的目标是计算第n个斐波那契数。在这里，我们可以使用动态规划来解决它。

动态规划解决该问题的一般步骤如下：

**DP 数组  以及下标含义**

初始化

递推公式（就固定那几种）

遍历顺序

打印DP数组，检查



1. **确定dp数组（dp table）以及下标的含义**
2. 确定递推公式
3. **dp数组如何初始化**
4. 确定遍历顺序
5. 举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**



发出这样的问题之前，其实可以自己先思考这三个问题：

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？



1. **定义状态**：首先，定义问题的状态。在斐波那契数列问题中，**状态可以表示为F(n)，表示第n个斐波那契数。**

2. **确定状态转移方程**：接下来，确定状态之间的关系，即状态转移方程。在斐波那契数列问题中，状态转移方程已经在定义中给出，即F(n) = F(n-1) + F(n-2)。

3. **初始化**：初始化边界状态，通常是最简单的状态。在斐波那契数列问题中，我们初始化F(0)和F(1)。

4. 自底向上计算：使用状态转移方程自底向上计算状态F(n)，从边界状态开始逐步计算，直到达到所需的状态F(n)。

5. 返回答案：最终，返回所需状态的值，这就是问题的答案。

动态规划的优势在于它避免了重复计算，**通过存储子问题的解，可以有效地解决复杂问题**。在上述斐波那契数列问题中，动态规划允许我们以线性时间复杂度解决问题，而不需要递归计算重复的子问题。

这只是动态规划的基本概念，实际上，动态规划可以应用于各种复杂问题，包括**最短路径、编辑距离、背包问题、子序列问题**等等。





## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)



假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```





爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。那么爬到第三层呢？
* 那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。
* 所以到**第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来**，那么就可以想到动态规划了。



**也就是后面的状态是由前面的状态推导而来，这样可以使用动态规划。**



好，那么看动态规划的五部曲：

1.**确定dp数组以及下标的含义**：**题目问的是多少种方法爬到楼梯顶，这个一般会给一个方向，dp[i]： 爬到第i层楼梯，有dp[i]种方法**

<br>

2.确定递推公式：

从dp[i]的定义可以看出，**dp[i] 可以有两个方向推出来。**

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，**那么再一步跳一个**台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，**那么再一步跳两个台阶**不就是dp[i]了么。

**那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！**

dp[i] = dp[i - 1] + dp[i - 2] 。**在推导dp[i]的时候，一定要时刻想着dp[i]的定义**，否则容易跑偏。**这体现出确定dp数组以及下标的含义的重要性！**

<br>

3. 数组的初始化：1<=n<=45

dp[0] 是多少？

题目中说了n是一个正整数，题目根本就没说n有为0的情况。

**所以本题其实就不应该讨论dp[0]的初始化！**

**我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。**

所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

<br>

4.确定遍历顺序

**从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的   而且初始化的时候看到了，是从3开始递推。**

此时大家应该发现了，这不就是斐波那契数列么！

**唯一的区别是，没有讨论dp[0]应该是什么，因为dp[0]在本题没有意义！**





```java
public int climbStairs(int n) {
	if (n <= 1) return n;       // 因为下面直接对dp[2]操作了，防止空指针
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n ; i++) {
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
}
```



拓展：这道题目还可以继续深化，**就是一步一个台阶，两个台阶，三个台阶，直到 m个台阶，有多少种方法爬到n阶楼顶。**



```c++
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) { // 把m换成2，就可以AC爬楼梯这道题
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
```



## [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```



有什么特点呢
* 一共numRows个数组
*  **第i个数组的大小为i**
*  **第0个位置和最后一个位置的值都为1**
* **第i个数组的第j个位置的值  = 第 i-1个数组的第 j-1个值  加上 第 i-1个数组的第 j个值的和**
*  如何初始化?
*  全部初始为1





```java
public List<List<Integer>> generate(int numRows) {

        /**
         * 有什么特点呢
         * 一共numRows个数组
         *  第i个数组的大小为i
         *  第0个位置和最后一个位置的值都为1
         *  第i个数组的第j个位置的值  = 第 i-1个数组的第 j-1个值  加上 第 i-1个数组的第 j个值的和
         *
         *  如何初始化?
         *  全部初始为1
         */

        Integer[][] dp = new Integer[numRows][];
        for (int i = 0; i < numRows; i++) {

            dp[i] = new Integer[i + 1];  //一共numRows个数组 第i个数组的大小为i
            dp[i][0] = 1;
            dp[i][i] = 1;

            // 计算中间元素
            for (int j = 0; j < i; j++) {
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
            }

        }

        // 将数组转化成列表
        List<List<Integer>> result = new ArrayList<>();

        for (Integer[] row : dp) {
            result.add(Arrays.asList(row));
        }
        return result;
    }
```





## [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```





当前房屋偷与不偷取决于 前一个房屋和前两个房屋是否被偷了。    要分析出这种取决关系
* 打家劫舍是dp解决的经典问题，接下来我们来动规五部曲分析如下
* dp数组的含义：**考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。**
* **如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i]**
* 如果**不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房），**
* 然后**dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);**
* 初始化   **dp[0] 和dp[1] 要初始化   dp[0] = nums[0]  dp[1] = max(num[0],nums[1])**
* 遍历顺序 ： dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是**从前到后遍历**！

```java
public int rob(int[] nums) {
        if(nums == null || nums.length ==0) return 0;
        if(nums.length == 1) return nums[0];

        int[] dp = new int[nums.length];

        // 这里用了dp[1]  那一定是有1的才行吧  所以上面得进行判断
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0],nums[1]);

        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1],dp[i-2] + nums[i]);
        }

        return dp[nums.length - 1];
    }
```





## [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)



你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

 

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

**示例 2：**

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 3：**

```
输入：nums = [1,2,3]
输出：3
```

 

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`



这道题目和[198.打家劫舍 (opens new window)](https://programmercarl.com/0198.打家劫舍.html)是差不多的，唯一区别就是成环了。

对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

![213.打家劫舍II](https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160748643-20230310134000692.jpg)

- 情况二：考虑包含首元素，不包含尾元素

![213.打家劫舍II1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160821374-20230310134003961.jpg)

- 情况三：考虑包含尾元素，不包含首元素

![213.打家劫舍II2](https://code-thinking-1253855093.file.myqcloud.com/pics/20210129160842491-20230310134008133.jpg)

**注意我这里用的是"考虑"**，例如情况三，**虽然是考虑包含尾元素，但不一定要选尾部元素！** 对于情况三，取nums[1] 和 nums[3]就是最大的。

**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了**



各种情况的考虑   抽象，然后又具体的言明出来。





```java
/**
     * 房屋都 围成一圈  这个怎么考虑  就是要考虑前两个和后两个
     * dp[i]   偷到第i间屋子时的最高金额
     * 递推公式
     * @param nums
     * @return
     */
    public int rob(int[] nums) {
        if(nums.length == 1){
            return nums[0];
        }

        // 求解第一个子问题（不偷最后一间房屋）
        int max1 = robHelper(nums, 0, nums.length - 2);
        // 求解第二个子问题（不偷第一间房屋）
        int max2 = robHelper(nums, 1, nums.length - 1);

        return Math.max(max1,max2);
    }



    private int robHelper(int[] nums, int start, int end){
        int prevMax = 0;
        int currentMax = 0;
        for (int i = start; i <= end ; i++) {
            int temp = currentMax;
            currentMax = Math.max(currentMax, prevMax + nums[i]);
            prevMax = temp;
        }
        return currentMax;
    }
```





## [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9
```



```java
/**
     * 将二叉树用数组存储?然后继续动态规划?
     * @param root
     * @return
     */
    public int rob(TreeNode root) {
        // 1. 递归去偷
        if(root == null) return 0;

        int money = root.val;
        if(root.left != null){
            money = money + rob(root.left.left) + rob(root.right.right);
        }

        if(root.right != null){
            money = money + rob(root.right.left) + rob(root.right.right);
        }

        return Math.max(money, rob(root.left) + rob(root.right));
    }


    // 2.递归去偷，记录状态   记忆化递归
    public int rob1(TreeNode root) {
        Map<TreeNode, Integer> memo = new HashMap<>();
        return robAction(root, memo);
    }

    private int robAction(TreeNode root, Map<TreeNode, Integer> memo) {
        if(root == null) return 0;

        if(memo.containsKey(root)){
            return memo.get(root);
        }
        int money = root.val;
        if (root.left != null) {
            money += robAction(root.left.left, memo) + robAction(root.left.right, memo);
        }
        if (root.right != null) {
            money += robAction(root.right.left, memo) + robAction(root.right.right, memo);
        }
        int res = Math.max(money, robAction(root.left, memo) + robAction(root.right, memo));
        memo.put(root, res);
        return res;
    }



    // 3.状态标记递归
    // 执行用时：0 ms , 在所有 Java 提交中击败了 100% 的用户
    // 不偷：Max(左孩子不偷，左孩子偷) + Max(右孩子不偷，右孩子偷)
    // root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) +
    // Math.max(rob(root.right)[0], rob(root.right)[1])
    // 偷：左孩子不偷+ 右孩子不偷 + 当前节点偷
    // root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
    public int rob3(TreeNode root) {
        int[] res = robAction1(root);
        return Math.max(res[0], res[1]);
    }

    int[] robAction1(TreeNode root) {
        int res[] = new int[2];
        if (root == null)
            return res;

        int[] left = robAction1(root.left);
        int[] right = robAction1(root.right);

        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        res[1] = root.val + left[0] + right[0];
        return res;
    }
```







## [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)



给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

 

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`





部分买卖股票的题目可以通过贪心或者其他的暴力方法解决，但是用动态规划是可以解决一系列问题的。



动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

**`dp[i][0] `表示第i天持有股票所得最多现金** ，**这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？**

其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。

**`dp[i][1] `表示第i天不持有股票所得最多现金**

**注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**

很多同学把“持有”和“买入”没区分清楚。

在下面递推公式分析中，我会进一步讲解。

1. 确定递推公式

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`

那么dp[i][0]应该选所得现金最大的，所以`dp[i][0] = max(dp[i - 1][0], -prices[i]);`

如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`



注意这里的为什么用的是持有

我们要想很清楚一点，**动态规划那个递推公式是什么，实际上是叫做状态转移方程。有几种状态是我们要考虑的，状态的包含也是要考虑的**



这样递推公式我们就分析完了

1. dp数组如何初始化

由递推公式 `dp[i][0] = max(dp[i - 1][0], -prices[i]); 和 dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`可以看出

其基础都是要从`dp[0][0]和dp[0][1]`推导出来。

那么`dp[0][0]`表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以`dp[0][0] -= prices[0];`

`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][1] = 0;`

1. 确定遍历顺序

从递推公式可以看出dp[i]都是由dp[i - 1]推导出来的，**那么一定是从前向后遍历。**

1. 举例推导dp数组

以示例1，输入：[7,1,5,3,6,4]为例，dp数组状态如下：

![121.买卖股票的最佳时机](https://code-thinking-1253855093.file.myqcloud.com/pics/20210224225642465.png)

`dp[5][1]`就是最终结果。

为什么不是`dp[5][0]`呢？

**因为本题中不持有股票状态所得金钱一定比持有股票状态得到的多！**



```java
public int maxProfit01(int[] prices) {
        if(prices == null || prices.length == 0) return 0;
        int length = prices.length;

        // dp[i][0]代表第i天持有股票的最大收益
        // dp[i][1]代表第i天不持有股票的最大收益
        int[][] dp = new int[length][2];

        dp[0][0] = -prices[0];
        dp[0][1] = 0;

        // 从1开始  因为0的时候已经初始化了
        for (int i = 1; i < length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0],-prices[i]);
            dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
        }
        return dp[length - 1][1];
    }
```





## 122.买卖股票的最佳时机II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

 

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```

 

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`





这里重申一下dp数组的含义：

- `dp[i][0] `表示第i天持有股票所得现金。
- `dp[i][1] `表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

**注意这里和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况**。

在[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)中，**因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即`dp[i][0]`一定就是 -prices[i]。**

**而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。**

那么第i天持有股票即dp[i][0]，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`。



再来看看如果第i天不持有股票即`dp[i][1]`的情况， 依然可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

**注意这里和[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.买卖股票的最佳时机.html)就是一样的逻辑，卖出股票收获利润（可能是负值）天经地义！**



```java
// 实现1：二维数组存储
    // 可以将每天持有与否的情况分别用 dp[i][0] 和 dp[i][1] 来进行存储
    // 时间复杂度：O(n)，空间复杂度：O(n)
    public int maxProfit01(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];     // 创建二维数组存储状态
        dp[0][0] = 0;                   // 初始状态
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; ++i) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);    // 第 i 天，没有股票
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    // 第 i 天，持有股票
        }
        return dp[n - 1][0];    // 卖出股票收益高于持有股票收益，因此取[0]
    }
```





## [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

**示例 2：**

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

**示例 3：**

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

**示例 4：**

```
输入：prices = [1]
输出：0
```

 

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 105`



**关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。**

要读出一些隐藏的含义



然后是状态的确定，也就是dp数组的确定

1. 没有操作 （其实我们也可以不设置这个状态）
2. 第一次持有股票
3. 第一次不持有股票
4. 第二次持有股票
5. 第二次不持有股票

dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

需要注意：`dp[i][1]`，**表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区**。

例如 dp[i][1] ，并不是说 第i天一定买入股票，有可能 第 i-1天 就买入了，那么 dp[i][1] 延续买入股票的这个状态。

1. 确定递推公式

达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么`dp[i][1] = dp[i-1][0] - prices[i]`
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

那么`dp[i][1]`究竟选 `dp[i-1][0] - prices[i]`，还是`dp[i - 1][1]`呢？

一定是选最大的，所以 `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);`

同理dp[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可推出剩下状态部分：

`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);`

`dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);`

1. dp数组如何初始化

第0天没有操作，这个最容易想到，就是0，即：`dp[0][0] = 0;`

第0天做第一次买入的操作，`dp[0][1] = -prices[0];`

第0天做第一次卖出的操作，这个初始值应该是多少呢？

此时还没有买入，怎么就卖出呢？ 其实大家可以理解当天买入，当天卖出，所以dp[0][2] = 0;

第0天第二次买入操作，初始值应该是多少呢？应该不少同学疑惑，第一次还没买入呢，怎么初始化第二次买入呢？

第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后再买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少。

所以第二次买入操作，初始化为：`dp[0][3] = -prices[0];`

同理第二次卖出初始化`dp[0][4] = 0;`

1. 确定遍历顺序

从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。

1. 举例推导dp数组

以输入[1,2,3,4,5]为例

![123.买卖股票的最佳时机III](https://code-thinking-1253855093.file.myqcloud.com/pics/20201228181724295-20230310134201291.png)

大家可以看到红色框为最后两次卖出的状态。

现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。如果想不明白的录友也可以这么理解：如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。所以`dp[4][4]已经包含了dp[4][2]`的情况。也就是说第二次卖出手里所剩的钱一定是最多的。

所以最终最大利润是`dp[4][4]`







## [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)



给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

**提示：**

- `1 <= k <= 100`
- `1 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`



这道题目可以说是[动态规划：123.买卖股票的最佳时机III (opens new window)](https://programmercarl.com/0123.买卖股票的最佳时机III.html)的进阶版，这里要求至多有k次交易。

动规五部曲，分析如下：

1. 确定dp数组以及下标的含义

在[动态规划：123.买卖股票的最佳时机III (opens new window)](https://programmercarl.com/0123.买卖股票的最佳时机III.html)中，我是定义了一个二维dp数组，本题其实依然可以用一个二维dp数组。

使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**大家应该发现规律了吧 ，除了0以外，偶数就是卖出，奇数就是买入**。

题目要求是至多有K笔交易，**那么j的范围就定义为 2 * k + 1 就可以了。**









## [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

**示例 2：**

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```



相对于[动态规划：122.买卖股票的最佳时机II (opens new window)](https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html)，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。

唯一差别在于递推公式部分，所以本篇也就不按照动规五部曲详细讲解了，主要讲解一下递推公式部分。

这里重申一下dp数组的含义：

dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

所以：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);`

在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，**注意这里需要有手续费了**即：`dp[i - 1][0] + prices[i] - fee`

所以：`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);`



```java
/**
 * 卖出时支付手续费
 * @param prices
 * @param fee
 * @return
 */
public int maxProfit(int[] prices, int fee) {
    int len = prices.length;
    // 0 : 持股（买入）
    // 1 : 不持股（售出）
    // dp 定义第i天持股/不持股 所得最多现金
    int[][] dp = new int[len][2];
    dp[0][0] = -prices[0];
    for (int i = 1; i < len; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
        dp[i][1] = Math.max(dp[i - 1][0] + prices[i] - fee, dp[i - 1][1]);
    }
    return Math.max(dp[len - 1][0], dp[len - 1][1]);
}

/**
 * 买入时支付手续费
 * @param prices
 * @param fee
 * @return
 */
public int maxProfit(int[] prices, int fee) {
    int len = prices.length;
    // 0 : 持股（买入）
    // 1 : 不持股（售出）
    // dp 定义第i天持股/不持股 所得最多现金
    int[][] dp = new int[len][2];
    // 考虑买入的时候就支付手续费
    dp[0][0] = -prices[0] - fee;
    for (int i = 1; i < len; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);
        dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);
    }
    return Math.max(dp[len - 1][0], dp[len - 1][1]);
}
```





## [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 104`



* 创建一个数组 dp，其中 dp[i] 表示数字 i 的最少完全平方数的数量。
* 对于每个数字 i，**遍历所有小于等于 i 的完全平方数 j * j，更新 dp[i]。**



```java
public int numSquares(int n) {
        /**
         * 创建一个数组 dp，其中 dp[i] 表示数字 i 的最少完全平方数的数量。
         * 对于每个数字 i，遍历所有小于等于 i 的完全平方数 j * j，更新 dp[i]。
         */

        int[] dp = new int[n + 1];
        Arrays.fill(dp,Integer.MAX_VALUE);

        dp[0] = 0;

        for (int i = 1; i <= n; i++) {
            // 遍历所有小于等于i的完全平方数
            for (int j = 1; j * j <= i; j++) {
                // 状态转移方程的推导
                dp[i] = Math.min(dp[i],dp[i - j*j] + 1);
            }
        }
        return dp[n];
    }
```





## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```



dp数组的含义   **dp[i]  表示兑换总金额为 i 需要 最少的硬币个数**

* 状态转移方程   `dp[i] = Min(dp[i],dp[i - coins[j] ] + 1)`  这里要遍历coins数组    i > coins数组中的一些值才能成立

和之前的完全平方数或者打家劫舍很像吧

**在想状态转移方程的时候，我们要想，动态规划后面的状态是和前面的状态有关联的，要想状态之间的关联**



```java
public int coinChange(int[] coins, int amount) {

        /**
         * dp数组的含义   dp[i]  表示兑换总金额为 i 需要 最少的硬币个数
         * 状态转移方程   dp[i] = Min(dp[i],dp[i - coins[j] ] + 1)  这里要遍历coins数组    i > coins数组中的一些值才能成立
         *
         * 但这又有一些问题了，有一些是不可达的，这怎么办呢
         * dp[0] = 0
         * 从前往后遍历
         */

        int[] dp = new int[amount + 1];
        Arrays.fill(dp,amount+1);
        dp[0] = 0;

        for (int i = 1; i <= amount ; i++) {

            for (int j = 0; j < coins.length; j++) {
                if(coins[j] <= i){
                    dp[i] = Math.min(dp[i],dp[i - coins[j]] + 1);
                }
            }
        }
		
    	//有一些是不可达的，这怎么办?这里就是判断是否可达了
        return dp[amount] > amount ? -1:dp[amount];
    }
```



## [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```



```java
public boolean wordBreak(String s, List<String> wordDict) {

        /**
         * 创建一个数组 dp，其中 dp[i] 表示字符串的前 i 个字符是否可以被空格拆分成字典中的单词。
         * 初始化数组，将 dp[0] 到 dp[n] 设置为 false，表示初始状态。
         * 对于每个位置 i，遍历字符串的前缀，检查是否存在一个位置 j，使得 dp[j] 为 true，且子串 s[j:i] 在字典中。
         * 如果找到这样的位置 j，则更新 dp[i] 为 true，表示字符串的前 i 个字符可以被拆分。
         * 返回 dp[n]，即整个字符串是否可以被拆分。
         */
        // 创建dp数组
        boolean[] dp = new boolean[s.length() + 1];
        // 初始化dp数组，将其设置为false
        dp[0] = true;

        // 遍历字符串
        for (int i = 1; i <= s.length(); i++) {
            // 遍历字符串的前缀
            for (int j = 0; j < i; j++) {
                // 检查是否存在一个位置j，使得dp[j]为true，并且子串s[j:i]在字典中
                if (dp[j] && wordDict.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.length()];


    }
```





## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，**删除（或不删除）数组中的元素而不改变其余元素的顺序。**例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```





首先通过本题大家要明确什么是子序列，“子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序”。

**子序列问题。**





定义 `dp[i]` 为考虑前 i 个元素，**以第 i个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。**

* 从小到大计算 dp 数组的值，在计算 dp[i]之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为：
* 注意两点   nums[i]  必须选  所以有时候得人为规定一下
* 遍历前面dp数组的时候： `num[j]<num[i]`
* `dp[i]=max(dp[j])+1`,其中 0≤j<i 且 num[j]<num[i]
* 最后最大上升子序列的   即为  max(dp[i])



**本题最关键的是要想到dp[i]由哪些状态可以推出来，并取最大值，那么很自然就能想到递推公式：dp[i] = max(dp[i], dp[j] + 1);**

```java
public int lengthOfLIS(int[] nums) {
    if(nums.length == 0){
        return 0;
    }

    int[] dp = new int[nums.length];
    dp[0] = 1;
    int result = 1;

    for (int i = 1; i < nums.length; i++) {
        dp[i] = 1;

        for (int j = 0; j < i; j++) {
            if(nums[i] > nums[j]){
                dp[i] = Math.max(dp[i],dp[j] + 1);
            }
        }

        result = Math.max(result,dp[i]);
    }
    return result;
}
```





## [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)



给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

 

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

**示例 2：**

```
输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`



```java
/**
     *
     * @param nums
     * @return
     */
    public int findLengthOfLCIS(int[] nums) {
        if(nums.length == 1){
            return 1;
        }

        int length = nums.length;
        int[] dp = new int[length];
        dp[0] = 1;
        int result = 1;

        for (int i = 0; i < dp.length; i++) {
            dp[i] = 1;
        }

        // 填充dp数组
        for (int i = 1; i < length; i++) {
            if(nums[i] > nums[i - 1]){
                dp[i] = dp[i - 1] + 1;
            }

            if(dp[i] > result) result = dp[i];
        }
        return result;
    }
```



本题相对于昨天的[动态规划：300.最长递增子序列 (opens new window)](https://programmercarl.com/0300.最长上升子序列.html)最大的区别在于“连续”。

本题要求的是最长**连续**递增序列

如果 nums[i] > nums[i - 1]，那么以 i 为结尾的连续递增的子序列长度 一定等于 以i - 1为结尾的连续递增的子序列长度 + 1 。

即：dp[i] = dp[i - 1] + 1;

**注意这里就体现出和[动态规划：300.最长递增子序列 (opens new window)](https://programmercarl.com/0300.最长上升子序列.html)的区别！**

**因为本题要求连续递增子序列，所以就只要比较nums[i]与nums[i - 1]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。**

**既然不用j了，那么也不用两层for循环，本题一层for循环就行，比较nums[i] 和 nums[i - 1]。**

这里大家要好好体会一下！



**要联动起来，才能理解递增子序列怎么求，递增连续子序列又要怎么求**。

概括来说：**不连续递增子序列的跟前0-i 个状态有关，连续递增的子序列只跟前一个状态有关**





## [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)



给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

 

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

**示例 2：**

```
输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
输出：5
```

 

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`





本题其实是动规解决的经典题目，我们只要想到 用二维数组可以记录两个字符串的所有比较情况，这样就比较好推 递推公式了。 动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j] `：**以下标i - 1为结尾的A，和以下标j - 1为结尾的B**，最长重复子数组长度为`dp[i][j]`。 （**特别注意**： “以下标i - 1为结尾的A” 标明一定是 以A[i-1]为结尾的字符串 ）

此时细心的同学应该发现，那`dp[0][0]`是什么含义呢？总不能是以下标-1为结尾的A数组吧。

其实`dp[i][j]`的定义也就决定着，我们在遍历`dp[i][j]`的时候i 和 j都要从1开始。

那有同学问了，我就定义`dp[i][j]`为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。不行么？

行倒是行！ 但实现起来就麻烦一点，需要单独处理初始化部分，在本题解下面的拓展内容里，我给出了 第二种 dp数组的定义方式所对应的代码和讲解，大家比较一下就了解了。

1. 确定递推公式

根据`dp[i][j]`的定义，dp[i][j]的状态只能由`dp[i - 1][j - 1]`推导出来。

即当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1;`

根据递推公式可以看出，遍历i 和 j 要从1开始！

1. dp数组如何初始化

根据dp[i][j]的定义，`dp[i][0] `和`dp[0][j]`其实都是没有意义的！

但`dp[i][0] `和`dp[0][j]`要初始值，因为 为了方便递归公式`dp[i][j] = dp[i - 1][j - 1] + 1`;

所以`dp[i][0] `和`dp[0][j]`初始化为0。

举个例子A[0]如果和B[0]相同的话，`dp[1][1] = dp[0][0] + 1`，只有`dp[0][0]`初始为0，正好符合递推公式逐步累加起来。

1. 确定遍历顺序

**外层for循环遍历A，内层for循环遍历B。**

**那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？**

也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。

同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把`dp[i][j]`的最大值记录下来。







```java
public int findLength(int[] nums1, int[] nums2) {
        int result = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];

        for (int i = 1; i < nums1.length + 1; i++) {
            for (int j = 1; j < nums2.length + 1; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    result = Math.max(result, dp[i][j]);
                }
            }
        }

        return result;
    }
```





## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

 

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**示例 2：**

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

**示例 3：**

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```





```java
public int longestCommonSubsequence(String text1, String text2) {
        // 获取字符串的长度
        int m = text1.length();
        int n = text2.length();

        // 创建一个二维数组来存储中间状态，其中 dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度
        int[][] dp = new int[m + 1][n + 1];

        //初始化  已经默认创建了全是0
        // 填充数组，从前往后遍历字符串

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {

                // 如果当前字符相等  最长公共子序列长度加一
                if(text1.charAt(i - 1)  == text2.charAt(j - 1)){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }else {
                    // 如果当前字符不相等，则取前一个状态中较大的值
                    // 注意dp数组的定义
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
```

**这种涉及到两个比较的，往往是要开二维的dp数组。**







## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。



**子数组**

是数组中的一个连续部分。



 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```



法一： 连续子数组的和  首先想到的是前缀和

构建前缀和数组，然后遍历前缀和数组相减，取最大值   时间复杂度O（n^2）

然后就超时了🤣

```java
public int maxSubArray02(int[] nums) {
        int length = nums.length;
        int[] preSum = new int[length + 1];

        // 构建前缀和数组
        preSum[0] = 0;
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }

        int result = Integer.MIN_VALUE;
        // 这里之前写了 i = 1，后面 j = i + 1,i凭啥等于1啊，那后面不就有可能超了嘛
        for (int i = 0; i < preSum.length; i++) {
            for (int j = i + 1; j < preSum.length; j++) {
                result = Math.max(result,preSum[j] - preSum[i]);
            }
        }
        return result;
    }
```





法二：动态规划

我们**用 f(i)代表以第 i个数结尾的「连续子数组的最大和」**，那么很显然我们要求的答案就是：**max{f(i)}**

* **f(i)=max{ f(i−1) + nums[i], nums[i] }**   这里看用一个数组来记录就可以
* 优化：small tricks
* 不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f数组来保存 f(i) 的值，用一个循环求出所有 f(i)
* 考虑到 f(i) 只和 f(i−1) 相关，于是我们**可以只用一个变量  来维护对于当前 f(i) 的 f(i−1)的值是多少，**
* 从而让空间复杂度降低到 O(1)，**这有点类似「滚动数组」的思想。**

```java
public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }

        int currentMax = nums[0]; // 以当前元素结尾的最大子数组和
        int globalMax = nums[0]; // 整个数组中的最大子数组和

        for (int i = 1; i < nums.length; i++) {
            // 计算以当前元素结尾的最大子数组和，或者从当前元素开始一个新的子数组
            currentMax = Math.max(currentMax + nums[i], nums[i]);
            // 更新整个数组中的最大子数组和
            globalMax = Math.max(globalMax, currentMax);
        }

        return globalMax;
    }
```



## [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)



给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**示例 1：**

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

**示例 2：**

```
输入：s = "axc", t = "ahbgdc"
输出：false
```





```java
public boolean isSubsequence(String s, String t) {
        int length1 = s.length(); int length2 = t.length();
        int[][] dp = new int[length1+1][length2+1];
        for(int i = 1; i <= length1; i++){
            for(int j = 1; j <= length2; j++){
                if(s.charAt(i-1) == t.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        if(dp[length1][length2] == length1){
            return true;
        }else{
            return false;
        }
    }
```





## [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。



测试用例的答案是一个 **32-位** 整数。

 

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```



**dp[i]   以dp[i] 为结尾的子数组的最大乘积   nums[i] 必选**  这个很常见了吧

   * 解题思路通常涉及动态规划，**需要维护一个最大值和一个最小值，**
   * 因为**负数乘以负数可能变成正数，所以需要同时维护最大值和最小值。**

```java
/**
     * dp[i]   以dp[i] 为结尾的子数组的最大乘积   nums[i] 必选
     * 最后结果就是max(dp[i])   错咯   是   那么根据「53. 最大子序和」的经验，我们很容易推导出这样的状态转移方程：max( f[n-1] * nums[i] )  1<=n<=i   又错咯
     *
     * 要考虑正负性的问题
     * 感觉还有点不对劲呀
     * a={5,6,−3,4,−3}那么此时 fmax
     * 对应的序列是 {5,30,−3,4,−3}，按照前面的算法我们可以得到答案为 30，即前两个数的乘积，而实际上答案应该是全体数字的乘积。我们来想一想问题出在哪里呢？问题出在最后一个 −3
     * 的值既不是 −3，也不是 4×(−3)4 ，而是 5×6×(−3)×4×(−3)
     * 所以我们得到了一个结论：当前位置的最优解未必是由前一个位置的最优解转移得到的。
     * 考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。
     * 如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 fmin(i)f
     *  它表示以第 i个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：

     *
     *
     * 状态转移方程是什么？
     *
     *
     * @param nums
     * @return
     */
    public int maxProduct(int[] nums) {

        /**
         * 解题思路通常涉及动态规划，需要维护一个最大值和一个最小值，
         * 因为负数乘以负数可能变成正数，所以需要同时维护最大值和最小值。
         *
         * 以下是一个基本的解题思路：
         *
         * 1. 遍历数组，同时维护当前的最大值 `maxProduct` 和最小值 `minProduct`。
         * 2. 对于每个元素，更新最大值和最小值：
         *    - 如果当前元素是正数，那么最大值和最小值分别乘以当前元素。
         *    - 如果当前元素是负数，交换最大值和最小值，然后再乘以当前元素。
         *    - 如果当前元素是0，重置最大值和最小值为1。
         * 3. 在遍历的过程中，不断更新最终的最大乘积。
         *
         * 这种方法确保了在遇到负数时，最小值也可能变成最大值。
         */

        if(nums == null || nums.length == 0){
            return 0;
        }

        int n = nums.length;
        // 初始化最大值和最小值
        int maxProduct = nums[0];
        int minProduct = nums[0];
        int result = nums[0];

        for (int i = 1; i < n; i++) {
            // 如果当前元素是负数，交换最大值和最小值，因为后面要进行负数的相乘，最大值乘负数就变成最小值了
            if(nums[i] < 0){
                int temp = maxProduct;
                maxProduct = minProduct;
                minProduct = temp;
            }
            // 更新最大值和最小值
            maxProduct = Math.max(nums[i], maxProduct * nums[i]);
            minProduct = Math.min(nums[i], minProduct * nums[i]);

            // 更新最终的最大乘积
            result = Math.max(result, maxProduct);
        }
        return result;
    }
```





## [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```



**这里引出了另一个东东了，背包问题！！！**

转化一下，其实，要分成两个和为   nums元素之和/2 的数组
* 背包的体积为sum / 2
* 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
* 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
* 背包中每一个元素是不可重复放入。
* 动态规划  01背包
* dp数组的含义  **dp[j]   当背包容量为j时，所能装的总重量（或者总价值）为dp[j]**
* 然后其他的和普通的01背包就没多大区别了



```java
 public boolean canPartition(int[] nums) {
        if(nums == null || nums.length == 0){
            return false;
        }
        int n = nums.length;
        int sum = 0;
        for (int num : nums) {
            sum = sum + num;
        }

        //总和为奇数，不能平分
        if(sum % 2 != 0) return false;
        int target = sum / 2;
        int[] dp = new int[target + 1];

        for (int i = 0; i < nums.length; i++) {
            // 遍历容量  倒序遍历  j>=nums[i]  仍然有容量装得下
            for (int j = target; j >= nums[i] ; j--) {
                dp[j] = Math.max(dp[j],dp[j - nums[i]] + nums[i]);
            }

            //剪枝一下，每一次完成內層的for-loop，立即檢查是否dp[target] == target，優化時間複雜度（26ms -> 20ms）
            if(dp[target] == target)
                return true;
        }
        return dp[target] == target;
    }
```







## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)



给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。



**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```



```java
/**
     * 一开始的思路，用栈  遇到左括号，入栈，遇到右括号，出栈
     *
     * 遇到左括号，入栈
     * 遇到右括号 假如栈中还有，那就出栈
     *
     * "()(()" 过不了，只能部分通过
     * @param s
     * @return
     */
    public static int longestValidParentheses(String s) {

        if(s.length() == 0){
            return 0;
        }

        int currentPair = 0;
        int maxPair = 0;
        ArrayDeque<Character> deque = new ArrayDeque<>();

        for(char c : s.toCharArray()){
            if(c == '('){
                deque.add('(');
            }else {
                // 遇到右括号，且栈中不为空
                if(!deque.isEmpty()){
                    deque.pop();
                    currentPair++;
//                    maxPair = Math.max(maxPair,currentPair);
                    // 这里的如何更新以及重置
                }else {
                    maxPair = Math.max(maxPair,currentPair);
                    currentPair = 0;
                }
            }
        }

        return maxPair * 2;

    }


    /**
     * Leetcode 用栈的题解
     * 始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：
     *
     * 对于遇到的每个 ‘(’ ，我们将它的下标放入栈中
     * 对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：
     * 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
     * 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
     * 我们从前往后遍历字符串并更新答案即可。
     *
     * 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，
     * 为了保持统一，我们在一开始的时候往栈中放入一个值为 −1 的元素。
     *
     */
    public static int longestValidParentheses01(String s) {
        int result = 0;
        Deque<Integer> stack = new LinkedList<>();
        stack.push(-1);

        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == '('){
                stack.push(i);
            }else {
                stack.pop();
                // 放最后一个未匹配的右括号进去，为什么?这样后面算长度的时候会有个标志分界
                if(stack.isEmpty()){
                    stack.push(i);
                }else {
                    result = Math.max(result, i - stack.peek());
                }
            }
        }
        return result;
    }


    public static void main(String[] args) {
        longestValidParentheses("(()");
    }


    /**
     * 在此方法中，我们利用两个计数器 left 和 right 。首先，我们从左到右遍历字符串，对于遇到的每个 ‘(’，我们增加 left 计数器，
     * 对于遇到的每个 ‘)’ ，我们增加 right 计数器。
     * 每当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串。
     * 当 right 计数器比 left 计数器大时，我们将 left 和 right 计数器同时变回 000。
     *
     * 这样的做法贪心地考虑了以当前字符下标结尾的有效括号长度，每
     * 次当右括号数量多于左括号数量的时候之前的字符我们都扔掉不再考虑，重新从下一个字符开始计算，
     * 但这样会漏掉一种情况，就是遍历的时候左括号的数量始终大于右括号的数量，即 (() ，这种时候最长有效括号是求不出来的。
     *
     * 解决的方法也很简单，我们只需要从右往左遍历用类似的方法计算即可，只是这个时候判断条件反了过来：
     *
     * 当 left 计数器比 right 计数器大时，我们将 left 和 right 计数器同时变回 0
     * 当 left 计数器与 right 计数器相等时，我们计算当前有效字符串的长度，并且记录目前为止找到的最长子字符串
     *
     * @param s
     * @return
     */
    public int longestValidParentheses03(String s) {
        int left = 0, right = 0, maxlength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxlength;
    }
```









## [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)



给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```







1.dp数组及其下标的含义：**到达第i个台阶所需的最小花费**

2.递推公式：**dp[i]  =Min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])**

3.递推公式的初始化：只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。

题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。

所以dp[0] = 0,dp[1] = 0

4.确定遍历顺序：从cost数组从前往后遍历







## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

**示例 1：**

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```





```java
/**
     * 不要因为这个归在动态规划就用动态规划
     *
     * 一个状态的结果，与前面的一个、两个、多个结果有关，就可以试着用动态规划
     *
     * 思路：
     * dp数组：m*n的二维数组，下标含义，到达dp[i][j] 的方法
     * 动态转移方程 dp[i][j] = dp[i-1][j] + dp[i][j-1]
     * 如何初始化：
     * ！！！首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理   并不一定只是盯着dp[1][0] 和dp[0][1]
     *
     * 遍历顺序 从左往右遍历
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }

        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }


        // 注意遍历的开始，也就是dp数组状态转移方程的的下标，从哪里开始
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m-1][n-1];
    }
```







## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)



给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

**提示:**

- `2 <= n <= 58`





两种想法，一种是拆成几个大小比较相近的数

* 第二个   i*(n - i)  **和前几个状态有关，所以可以用动态规划  **

**动态规划的运用，不一定是和前面一个状态有关，和前面的状态有关即可**





dp数组及其下标的含义：dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
* **递推公式：dp[i]  最大乘积  拆分成两个，就是 `j*(i-j)`,拆分成三个及以上，就是  `j*dp[i-j]`,然后取最大值即可**
* dp数组初始化：严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。
* 拆分0和拆分1的最大乘积是多少？这是无解的。
* 确定遍历顺序，先来看看递归公式：**dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));**
* dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。
* 那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。因为i-j后面又回去了





```java
 		int[] dp = new int[n + 1];
        dp[2] = 1;
        // 开了n+1个长度，这个是dp数组要注意的
        for (int i = 3; i <= n; i++) {
            // 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0 注意 i/j的意义是什么
            for (int j = 1; j < i/2; j++) {
                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));
            }
        }
        return dp[n];
```

