---
title: 二叉树习题
date: 2024-03-10 20:26:34
permalink: /pages/02ca89/
categories:
  - 计算机基础
  - Leetcode
tags:
  - 
---
# 二叉树习题

**做二叉树的题目，感觉一是要确定遍历方式。二是要确定递归的写法**



## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)



中序遍历：左 中 右

迭代遍历的话，中序遍历会造成访问的顺序和要处理的顺序不一致的问题，这时候就要用个指针变量来进行记录

```java
public List<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        // 需要一个指针变量来记住  因为遍历的顺序和处理的顺序不一致
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            if(cur != null){
                stack.push(cur);
                cur = cur.left;         // 左
            }else {    //一定要有这个else
                // cur为空了,也就是向左到头了,或者右也为空了
                cur = stack.pop();      //出栈，拿节点  中
                result.add(cur.val);
                cur = cur.right;        // 右
            }

        }
        return result;
    }
```



## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

 ![image-20231030110648748](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231030110648748.png)

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

 

```java
public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftDepth = maxDepth(root.left);    // 左
        int rightDepth = maxDepth(root.right);  // 右
        return Math.max(leftDepth, rightDepth) + 1;//中
    }
```





## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)



给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```



还是那样，确定遍历方式，确定递归写法



前后序遍历都可以

* 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）



法一：前序遍历

```java
public TreeNode invertTree(TreeNode root) {
        if (root == null){
            return null;
        }

        swapChildren(root); // 中
        invertTree(root.left);  //左
        invertTree(root.right);  //右
        return root;
    }


    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
```



法二：层序遍历

```java
// 层序遍历实现交换
    public TreeNode invertTree01(TreeNode root) {
        if (root == null) {return null;}
        ArrayDeque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                swap(node);
                if (node.left != null) deque.offer(node.left);
                if (node.right != null) deque.offer(node.right);
            }
        }
        return root;
    }

    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
```



## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```



判断对称二叉树要比较的是哪两个节点，**要比较的可不是左右节点！**
* **比较的是两个子树的里侧和外侧的元素是否相等。**
* 那么遍历的顺序应该是什么样的呢？ 二叉树的遍历顺序很重要！！！每次都要考虑这个问题
* 正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是**一个树的遍历顺序是左右中**，**一个树的遍历顺序是右左中。**
* 但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。
* 其实**后序也可以理解为是一种回溯**，当然这是题外话，讲回溯的时候会重点讲的。
* 用递归来做





```java
public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    boolean compare(TreeNode left,TreeNode right){
        // 先考虑为空的情况
        if(left == null && right != null){
            return false;
        }
        if(left != null && right == null){
            return false;
        }
        if(left == null && right == null){
            return true;
        }
        // 都不为空，比较数值
        if(left.val != right.val){
            return false;
        }
        // 比较外侧
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
```





法二：迭代法

```java
/**
     * 迭代法
     * 使用双端队列，相当于两个栈
     */
    public boolean isSymmetric2(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerFirst(root.left);    //将左子树头结点加入队列
        deque.offerLast(root.right);    //将右子树头结点加入队列
        while (!deque.isEmpty()) {
            TreeNode leftNode = deque.pollFirst();      // 双端队列  pollFirst  和 pollLast
            TreeNode rightNode = deque.pollLast();
            if (leftNode == null && rightNode == null) {
                continue;
            }
//            if (leftNode == null && rightNode != null) {
//                return false;
//            }
//            if (leftNode != null && rightNode == null) {
//                return false;
//            }
//            if (leftNode.val != rightNode.val) {
//                return false;
//            }
            // 以上三个判断条件合并
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            deque.offerFirst(leftNode.left);    // 加入左节点左孩子
            deque.offerFirst(leftNode.right);   //加入左节点右孩子
            deque.offerLast(rightNode.right);   //右节点右孩子
            deque.offerLast(rightNode.left);    //右节点左孩子
        }
        return true;
    }

```





## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)



给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```





给你一棵二叉树的根节点，返回该树的直径 。
* 二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。**这条路径可能经过也可能不经过根节点 root 。**
* 两节点之间路径的 长度 由它们之间边数表示。
* **不经过root 是因为可能子节点的左叶子到右叶子距离更长**



1.一条路径的长度为该路径经过的节点数减一  两端嘛

2.所以**求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。**

3.而**任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。  拆分**

4.假设我们知道对于该节点的**左儿子向下遍历经过最多的节点数 L**（即以左儿子为根的子树的深度）

**和其右儿子向下遍历经过最多的节点数 R**（即以右儿子为根的子树的深度），

那么**以该节点为起点的路径经过节点数的最大值即为 L+R+1。**               （假设设变量 量化）

5.那么二叉树的直径就是所有节点 dnode的最大值减一。

算法：**我们定义一个递归函数 depth(node) 计算 dnode**

函数返回该节点为根的子树的深度。**先递归调用左儿子和右儿子求得它们为根的子树的深度 L和 R，则该节点为根的子树的深度即为**

**max(L,R)+1**

该节点的 dnode值为L+R+1

**递归搜索每个节点并设一个全局变量 ans记录 dnode的最大值**，最后返回 result-1 即为树的直径。



```java
	int ans;

    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;    //一条路径的长度为该路径经过的节点数减一
    }

    public int depth(TreeNode node){
        if(node == null){
            return 0;
        }
        int L = depth(node.left);
        int R = depth(node.right);
        ans = Math.max(ans,L+R+1);
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度  以节点为基础   左右路径分开
    }
```



就递归看起来代码量很少，但实际上得理清楚





## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)



给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 

平衡

 二叉搜索树。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

 

```java
public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }
```







## [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左

  子树

  只包含

   小于 

  当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

 



一个重要的特性：

**要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。**

* 有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。

1.**不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。**

**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。**所以以上代码的判断逻辑是错误的。

2.样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。

此时可以初始化比较元素为longlong的最小值。

3.如果是空节点 是不是二叉搜索树呢？

**是的，二叉搜索树也可以为空！**

4.单层递归的逻辑

**中序遍历，一直更新maxVal，一旦发现maxVal >= root->val，就返回false，注意元素相同时候也要返回false。**



```java
TreeNode max;// 用来记录前一个节点

    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        // 左
        boolean left = isValidBST(root.left);
        if(left == false){
            return false;
        }
        //中  这里的root是当前节点   然后max是前一个节点
        // 中序遍历下，输出的二叉搜索树节点的数值是有序序列。 所以假如value值小了，说明就不是二叉搜索树了
        if(max != null && root.val <= max.val){
            return false;
        }
        max = root;// 用来记录前一个节点

        // 右
        boolean right = isValidBST(root.right);
        return right;
    }

```



## [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)



给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

 

 仍然是利用之前的特性，中序遍历二叉搜索树出来个有序序列

```java
public List<Integer> treeNodeList = new ArrayList<>();
    
    public int kthSmallest(TreeNode root, int k) {
        inorder(root);
        return treeNodeList.get(k - 1);
    }
    
    public void inorder(TreeNode root){
        if(root == null){
            return;
        }
        inorder(root.left);
        treeNodeList.add(root.val);
        inorder(root.right);
    }
```







## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

 



层序遍历，取出最右边的那个

```java
/**
     * 解法：队列，迭代。
     * 每次返回每层的最后一个字段即可。
     *
     * 小优化：每层右孩子先入队。代码略。
     */
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Deque<TreeNode> que = new LinkedList<>();

        if (root == null) {
            return list;
        }

        que.offerLast(root);
        while (!que.isEmpty()) {
            int levelSize = que.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode poll = que.pollFirst();

                if (poll.left != null) {
                    que.addLast(poll.left);
                }
                if (poll.right != null) {
                    que.addLast(poll.right);
                }

                if (i == levelSize - 1) {
                    list.add(poll.val);
                }
            }
        }

        return list;
    }
```





## [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 



法一：

第一种方法就是**开个ArraryList存TreeNode,然后再连接起来，这样时间复杂度O（n） 空间复杂度O（n）**
* 由于**将节点展开之后会破坏二叉树的结构而丢失子节点的信息，**因此前序遍历和展开为单链表分成了两步。
* 能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？



faer：

**之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，**在遍历完左子树之后才获得右子节点的信息。

* 只要**对前序遍历进行修改，在遍历左子树之前就获得左右子节点的信息，并存入栈内，子节点的信息就不会丢失**，就可以将前序遍历和展开为单链表同时进行。
* **该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历**。
* 每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，**则依次将右子节点和左子节点压入栈内（注意入栈顺序）。**
* 展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，
* 将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。
* 需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。



```java
public void flatten(TreeNode root) {
        if(root == null){
            return;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        stack.push(root);
        TreeNode prev = null;
        while (!stack.isEmpty()){
            TreeNode curr = stack.pop();
            //连接链表
            if(prev != null){
                prev.left = null;
                prev.right = curr;
            }
            // 入栈左右节点
            TreeNode left = curr.left, right = curr.right;
            // 先入右节点，再入左节点
            if (right != null) {
                stack.push(right);
            }
            if (left != null) {
                stack.push(left);
            }
            //迭代 往左走
            prev = curr;

        }

    }
```





## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```



前序先遍历到的是中，
* 中序是左中右
* 前序 找到中，**去中序数组中找对应的，左边就是左子树，右边就是右子树**



在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。
* 我们可以**考虑使用哈希表来帮助我们快速地定位根节点。**
* 对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。
* 在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。
* 在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。



```java
private Map<Integer, Integer> indexMap;    // key是中序遍历TreeNode的值，value是数组中的下标，因为是从中序中进行拆分

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder,
                                int preorderLeft, int preorderRight, int inorderLeft, int inorderRight)
    {

        if(preorderLeft > preorderRight){
            return null;
        }
        int preorderRoot = preorderLeft;
        int inorderRoot = indexMap.get(preorder[preorderRoot]);
        TreeNode root = new TreeNode(preorder[preorderRoot]);

        // 左子树的数目
        int leftSubTree = inorderRoot - inorderLeft;
        
        //这个递归之所以设置这么多参数，就在于他不用拆分数组了，直接再原有的数组基础上，用下标进行分割
        root.left = myBuildTree(preorder,inorder,preorderLeft +1,
                preorderLeft + leftSubTree,inorderLeft,inorderRoot - 1);
        
        // 先序遍历中「从 左边界+1+左子树节点数目(右子树开始  如何衡量右子树，以左子树的数量来衡量) 开始到 右边界」的元素就对应了 中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder,inorder,
                preorderLeft + leftSubTree +1,preorderRight,inorderRoot +1,inorderRight);
        return root;
    }
```





## [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```



**穷举所有的可能**，我们访问每一个节点 node，**检测以 node 为起始节点且向下延深的路径有多少种。**

* 我们**递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。**
*  **rootSum(p,val) 表示以节点 p为起点向下且满足路径总和为 val 的路径数目。**
*  我们对二叉树上每个节点 p求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。
* 对**左右子节点进行递归：**
* 以当前节点 p为目标路径的起点递归向下进行搜索。
* 假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 pl，**求出 rootSum(pl,targetSum−val)**
* 同理右孩子，同时我们还需要判断一下当前节点 p的值是否刚好等于 targetSum。



```java
public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }

        int ret = rootSum(root, targetSum);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;

    }

    public int rootSum(TreeNode root,int targetSum){
        int result = 0;
        if(root == null){
            return 0;
        }
        int val = root.val;
        if(val == targetSum){
            result++;
        }
        // 这里减去 val 进行递归很关键
        result += rootSum(root.left,targetSum-val);
        result += rootSum(root.right,targetSum - val);
        return result;

    }
```





## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```





我们可以**用哈希表存储所有节点的父节点**，然后我们就可以**利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，**
* 再从 q 节点开始不断往上跳，**如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。**
* 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。
* 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。  一直往上走
* 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。



```java
Map<Integer, TreeNode> parent = new HashMap<Integer, TreeNode>();
    Set<Integer> visited = new HashSet<Integer>();

    public void dfs(TreeNode root) {
        if (root.left != null) {
            parent.put(root.left.val, root);    // 用于记录父节点TreeNode   key是子节点的val，value 是父节点
            dfs(root.left);
        }
        if (root.right != null) {
            parent.put(root.right.val, root);
            dfs(root.right);
        }
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root);
        while (p != null) {
            visited.add(p.val);     //路过一个，将val放到set里面，下次再check有的时候就相当于遇到了
            p = parent.get(p.val);
        }
        while (q != null) {
            if (visited.contains(q.val)) {
                return q;
            }
            q = parent.get(q.val);
        }
        return null;
    }
```



## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

 

```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node.val + Math.max(leftGain, rightGain);
    }
}


```









