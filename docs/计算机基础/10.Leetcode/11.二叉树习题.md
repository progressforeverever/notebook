---
title: 二叉树习题
date: 2024-03-10 20:26:34
permalink: /pages/02ca89/
categories:
  - 计算机基础
  - Leetcode
tags:
  - 
---
# 二叉树习题

**做二叉树的题目，感觉一是要确定遍历方式。二是要确定递归的写法**



## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)



中序遍历：左 中 右

迭代遍历的话，中序遍历会造成访问的顺序和要处理的顺序不一致的问题，这时候就要用个指针变量来进行记录

```java
public List<Integer> inorderTraversal(TreeNode root) {
        ArrayList<Integer> result = new ArrayList<>();
        if(root == null){
            return result;
        }
        Stack<TreeNode> stack = new Stack<>();
        // 需要一个指针变量来记住  因为遍历的顺序和处理的顺序不一致
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            if(cur != null){
                stack.push(cur);
                cur = cur.left;         // 左
            }else {    //一定要有这个else
                // cur为空了,也就是向左到头了,或者右也为空了
                cur = stack.pop();      //出栈，拿节点  中
                result.add(cur.val);
                cur = cur.right;        // 右
            }

        }
        return result;
    }
```



## [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

 ![image-20231030110648748](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231030110648748.png)

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

 

```java
public int maxDepth(TreeNode root) {
        if(root == null){
            return 0;
        }
        int leftDepth = maxDepth(root.left);    // 左
        int rightDepth = maxDepth(root.right);  // 右
        return Math.max(leftDepth, rightDepth) + 1;//中
    }
```





## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)



给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```



还是那样，确定遍历方式，确定递归写法



前后序遍历都可以

* 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）



法一：前序遍历

```java
public TreeNode invertTree(TreeNode root) {
        if (root == null){
            return null;
        }

        swapChildren(root); // 中
        invertTree(root.left);  //左
        invertTree(root.right);  //右
        return root;
    }


    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
```



法二：层序遍历

```java
// 层序遍历实现交换
    public TreeNode invertTree01(TreeNode root) {
        if (root == null) {return null;}
        ArrayDeque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (!deque.isEmpty()) {
            int size = deque.size();
            while (size-- > 0) {
                TreeNode node = deque.poll();
                swap(node);
                if (node.left != null) deque.offer(node.left);
                if (node.right != null) deque.offer(node.right);
            }
        }
        return root;
    }

    public void swap(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
```



## [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```



判断对称二叉树要比较的是哪两个节点，**要比较的可不是左右节点！**
* **比较的是两个子树的里侧和外侧的元素是否相等。**
* 那么遍历的顺序应该是什么样的呢？ 二叉树的遍历顺序很重要！！！每次都要考虑这个问题
* 正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是**一个树的遍历顺序是左右中**，**一个树的遍历顺序是右左中。**
* 但都可以理解算是后序遍历，尽管已经不是严格上在一个树上进行遍历的后序遍历了。
* 其实**后序也可以理解为是一种回溯**，当然这是题外话，讲回溯的时候会重点讲的。
* 用递归来做





```java
public boolean isSymmetric(TreeNode root) {
        return compare(root.left, root.right);
    }

    boolean compare(TreeNode left,TreeNode right){
        // 先考虑为空的情况
        if(left == null && right != null){
            return false;
        }
        if(left != null && right == null){
            return false;
        }
        if(left == null && right == null){
            return true;
        }
        // 都不为空，比较数值
        if(left.val != right.val){
            return false;
        }
        // 比较外侧
        boolean compareOutside = compare(left.left, right.right);
        // 比较内侧
        boolean compareInside = compare(left.right, right.left);
        return compareOutside && compareInside;
    }
```





法二：迭代法

```java
/**
     * 迭代法
     * 使用双端队列，相当于两个栈
     */
    public boolean isSymmetric2(TreeNode root) {
        Deque<TreeNode> deque = new LinkedList<>();
        deque.offerFirst(root.left);    //将左子树头结点加入队列
        deque.offerLast(root.right);    //将右子树头结点加入队列
        while (!deque.isEmpty()) {
            TreeNode leftNode = deque.pollFirst();      // 双端队列  pollFirst  和 pollLast
            TreeNode rightNode = deque.pollLast();
            if (leftNode == null && rightNode == null) {
                continue;
            }
//            if (leftNode == null && rightNode != null) {
//                return false;
//            }
//            if (leftNode != null && rightNode == null) {
//                return false;
//            }
//            if (leftNode.val != rightNode.val) {
//                return false;
//            }
            // 以上三个判断条件合并
            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {
                return false;
            }
            deque.offerFirst(leftNode.left);    // 加入左节点左孩子
            deque.offerFirst(leftNode.right);   //加入左节点右孩子
            deque.offerLast(rightNode.right);   //右节点右孩子
            deque.offerLast(rightNode.left);    //右节点左孩子
        }
        return true;
    }

```





## [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)



给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```





给你一棵二叉树的根节点，返回该树的直径 。
* 二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。**这条路径可能经过也可能不经过根节点 root 。**
* 两节点之间路径的 长度 由它们之间边数表示。
* **不经过root 是因为可能子节点的左叶子到右叶子距离更长**



1.一条路径的长度为该路径经过的节点数减一  两端嘛

2.所以**求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。**

3.而**任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。  拆分**

4.假设我们知道对于该节点的**左儿子向下遍历经过最多的节点数 L**（即以左儿子为根的子树的深度）

**和其右儿子向下遍历经过最多的节点数 R**（即以右儿子为根的子树的深度），

那么**以该节点为起点的路径经过节点数的最大值即为 L+R+1。**               （假设设变量 量化）

5.那么二叉树的直径就是所有节点 dnode的最大值减一。

算法：**我们定义一个递归函数 depth(node) 计算 dnode**

函数返回该节点为根的子树的深度。**先递归调用左儿子和右儿子求得它们为根的子树的深度 L和 R，则该节点为根的子树的深度即为**

**max(L,R)+1**

该节点的 dnode值为L+R+1

**递归搜索每个节点并设一个全局变量 ans记录 dnode的最大值**，最后返回 result-1 即为树的直径。



```java
	int ans;

    public int diameterOfBinaryTree(TreeNode root) {
        ans = 1;
        depth(root);
        return ans - 1;    //一条路径的长度为该路径经过的节点数减一
    }

    public int depth(TreeNode node){
        if(node == null){
            return 0;
        }
        int L = depth(node.left);
        int R = depth(node.right);
        ans = Math.max(ans,L+R+1);
        return Math.max(L, R) + 1; // 返回该节点为根的子树的深度  以节点为基础   左右路径分开
    }
```



就递归看起来代码量很少，但实际上得理清楚





## [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)



给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 

平衡

 二叉搜索树。



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

 

```java
public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        // 总是选择中间位置左边的数字作为根节点
        int mid = (left + right) / 2;

        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }
```







## [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左

  子树

  只包含

   小于 

  当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

 



一个重要的特性：

**要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。**

* 有了这个特性，验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。

1.**不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。**

**我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。**所以以上代码的判断逻辑是错误的。

2.样例中最小节点 可能是int的最小值，如果这样使用最小的int来比较也是不行的。

此时可以初始化比较元素为longlong的最小值。

3.如果是空节点 是不是二叉搜索树呢？

**是的，二叉搜索树也可以为空！**

4.单层递归的逻辑

**中序遍历，一直更新maxVal，一旦发现maxVal >= root->val，就返回false，注意元素相同时候也要返回false。**



```java
TreeNode max;// 用来记录前一个节点

    public boolean isValidBST(TreeNode root) {
        if(root == null){
            return true;
        }
        // 左
        boolean left = isValidBST(root.left);
        if(left == false){
            return false;
        }
        //中  这里的root是当前节点   然后max是前一个节点
        // 中序遍历下，输出的二叉搜索树节点的数值是有序序列。 所以假如value值小了，说明就不是二叉搜索树了
        if(max != null && root.val <= max.val){
            return false;
        }
        max = root;// 用来记录前一个节点

        // 右
        boolean right = isValidBST(root.right);
        return right;
    }

```



## [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)



给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

 

 仍然是利用之前的特性，中序遍历二叉搜索树出来个有序序列

```java
public List<Integer> treeNodeList = new ArrayList<>();
    
    public int kthSmallest(TreeNode root, int k) {
        inorder(root);
        return treeNodeList.get(k - 1);
    }
    
    public void inorder(TreeNode root){
        if(root == null){
            return;
        }
        inorder(root.left);
        treeNodeList.add(root.val);
        inorder(root.right);
    }
```







## [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

```
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

**示例 2:**

```
输入: [1,null,3]
输出: [1,3]
```

**示例 3:**

```
输入: []
输出: []
```

 



层序遍历，取出最右边的那个

```java
/**
     * 解法：队列，迭代。
     * 每次返回每层的最后一个字段即可。
     *
     * 小优化：每层右孩子先入队。代码略。
     */
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Deque<TreeNode> que = new LinkedList<>();

        if (root == null) {
            return list;
        }

        que.offerLast(root);
        while (!que.isEmpty()) {
            int levelSize = que.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode poll = que.pollFirst();

                if (poll.left != null) {
                    que.addLast(poll.left);
                }
                if (poll.right != null) {
                    que.addLast(poll.right);
                }

                if (i == levelSize - 1) {
                    list.add(poll.val);
                }
            }
        }

        return list;
    }
```





## [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

 



法一：

第一种方法就是**开个ArraryList存TreeNode,然后再连接起来，这样时间复杂度O（n） 空间复杂度O（n）**
* 由于**将节点展开之后会破坏二叉树的结构而丢失子节点的信息，**因此前序遍历和展开为单链表分成了两步。
* 能不能在不丢失子节点的信息的情况下，将前序遍历和展开为单链表同时进行？



faer：

**之所以会在破坏二叉树的结构之后丢失子节点的信息，是因为在对左子树进行遍历时，没有存储右子节点的信息，**在遍历完左子树之后才获得右子节点的信息。

* 只要**对前序遍历进行修改，在遍历左子树之前就获得左右子节点的信息，并存入栈内，子节点的信息就不会丢失**，就可以将前序遍历和展开为单链表同时进行。
* **该做法不适用于递归实现的前序遍历，只适用于迭代实现的前序遍历**。
* 每次从栈内弹出一个节点作为当前访问的节点，获得该节点的子节点，如果子节点不为空，**则依次将右子节点和左子节点压入栈内（注意入栈顺序）。**
* 展开为单链表的做法是，维护上一个访问的节点 prev，每次访问一个节点时，令当前访问的节点为 curr，
* 将 prev 的左子节点设为 null 以及将 prev 的右子节点设为 curr，然后将 curr 赋值给 prev，进入下一个节点的访问，直到遍历结束。
* 需要注意的是，初始时 prev 为 null，只有在 prev 不为 null 时才能对 prev 的左右子节点进行更新。



```java
public void flatten(TreeNode root) {
        if(root == null){
            return;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        stack.push(root);
        TreeNode prev = null;
        while (!stack.isEmpty()){
            TreeNode curr = stack.pop();
            //连接链表
            if(prev != null){
                prev.left = null;
                prev.right = curr;
            }
            // 入栈左右节点
            TreeNode left = curr.left, right = curr.right;
            // 先入右节点，再入左节点
            if (right != null) {
                stack.push(right);
            }
            if (left != null) {
                stack.push(left);
            }
            //迭代 往左走
            prev = curr;

        }

    }
```





## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

**示例 2:**

```
输入: preorder = [-1], inorder = [-1]
输出: [-1]
```



前序先遍历到的是中，
* 中序是左中右
* 前序 找到中，**去中序数组中找对应的，左边就是左子树，右边就是右子树**



在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。
* 我们可以**考虑使用哈希表来帮助我们快速地定位根节点。**
* 对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。
* 在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。
* 在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。



```java
private Map<Integer, Integer> indexMap;    // key是中序遍历TreeNode的值，value是数组中的下标，因为是从中序中进行拆分

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    public TreeNode myBuildTree(int[] preorder, int[] inorder,
                                int preorderLeft, int preorderRight, int inorderLeft, int inorderRight)
    {

        if(preorderLeft > preorderRight){
            return null;
        }
        int preorderRoot = preorderLeft;
        int inorderRoot = indexMap.get(preorder[preorderRoot]);
        TreeNode root = new TreeNode(preorder[preorderRoot]);

        // 左子树的数目
        int leftSubTree = inorderRoot - inorderLeft;
        
        //这个递归之所以设置这么多参数，就在于他不用拆分数组了，直接再原有的数组基础上，用下标进行分割
        root.left = myBuildTree(preorder,inorder,preorderLeft +1,
                preorderLeft + leftSubTree,inorderLeft,inorderRoot - 1);
        
        // 先序遍历中「从 左边界+1+左子树节点数目(右子树开始  如何衡量右子树，以左子树的数量来衡量) 开始到 右边界」的元素就对应了 中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder,inorder,
                preorderLeft + leftSubTree +1,preorderRight,inorderRoot +1,inorderRight);
        return root;
    }
```





## [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```



**穷举所有的可能**，我们访问每一个节点 node，**检测以 node 为起始节点且向下延深的路径有多少种。**

* 我们**递归遍历每一个节点的所有可能的路径，然后将这些路径数目加起来即为返回结果。**
*  **rootSum(p,val) 表示以节点 p为起点向下且满足路径总和为 val 的路径数目。**
*  我们对二叉树上每个节点 p求出 rootSum(p,targetSum)，然后对这些路径数目求和即为返回结果。
* 对**左右子节点进行递归：**
* 以当前节点 p为目标路径的起点递归向下进行搜索。
* 假设当前的节点 p 的值为 val，我们对左子树和右子树进行递归搜索，对节点 p 的左孩子节点 pl，**求出 rootSum(pl,targetSum−val)**
* 同理右孩子，同时我们还需要判断一下当前节点 p的值是否刚好等于 targetSum。



```java
public int pathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return 0;
        }

        int ret = rootSum(root, targetSum);
        ret += pathSum(root.left, targetSum);
        ret += pathSum(root.right, targetSum);
        return ret;

    }

    public int rootSum(TreeNode root,int targetSum){
        int result = 0;
        if(root == null){
            return 0;
        }
        int val = root.val;
        if(val == targetSum){
            result++;
        }
        // 这里减去 val 进行递归很关键
        result += rootSum(root.left,targetSum-val);
        result += rootSum(root.right,targetSum - val);
        return result;

    }
```





## [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```





我们可以**用哈希表存储所有节点的父节点**，然后我们就可以**利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，**
* 再从 q 节点开始不断往上跳，**如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。**
* 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。
* 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。  一直往上走
* 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。



```java
Map<Integer, TreeNode> parent = new HashMap<Integer, TreeNode>();
    Set<Integer> visited = new HashSet<Integer>();

    public void dfs(TreeNode root) {
        if (root.left != null) {
            parent.put(root.left.val, root);    // 用于记录父节点TreeNode   key是子节点的val，value 是父节点
            dfs(root.left);
        }
        if (root.right != null) {
            parent.put(root.right.val, root);
            dfs(root.right);
        }
    }

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        dfs(root);
        while (p != null) {
            visited.add(p.val);     //路过一个，将val放到set里面，下次再check有的时候就相当于遇到了
            p = parent.get(p.val);
        }
        while (q != null) {
            if (visited.contains(q.val)) {
                return q;
            }
            q = parent.get(q.val);
        }
        return null;
    }
```





来看另一种方法：

**遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。**

**那么二叉树如何可以自底向上查找呢？**

**回溯**啊，二叉树回溯的过程就是从低到上。

**后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。**

接下来就看如何判断一个节点是节点q和节点p的公共祖先呢。

**首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。** 即情况一：

![image-20240320122416433](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20240320122416433.png)

判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。



![image-20240320122456042](https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20240320122456042.png)



那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。

如图：

![236.二叉树的最近公共祖先](https://code-thinking-1253855093.file.myqcloud.com/pics/2021020415105872.png)

**如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解**

**如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然**。

这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢？

如图：

![236.二叉树的最近公共祖先1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204151125844.png)



那么寻找最小公共祖先，完整流程图如下：

![236.二叉树的最近公共祖先2](https://code-thinking-1253855093.file.myqcloud.com/pics/202102041512582.png)

**从图中，大家可以看到，我们是如何回溯遍历整棵二叉树，将结果返回给头结点的！**



**那么我给大家归纳如下三点**：

1. 求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。
2. 在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
3. 要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。

可以说这里每一步，都是有难度的，都需要对二叉树，递归和回溯有一定的理解。





```java
public TreeNode lowestCommonAncestor01(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;
        
        // 如果当前节点遇到了p 或者q 那么就直接返回，表示已经遇到了
        if(root == p || root == q){
            return root;
        }

        TreeNode left = lowestCommonAncestor01(root.left, p, q);
        TreeNode right = lowestCommonAncestor01(root.right, p, q);
        
        if(left == null && right == null){      // 未找到节点p/q
            return null;
        } else if (left == null && right != null) {  // 只找到一个节点
            return right;
        } else if (left != null && right == null) {   // 只找到一个节点
            return left;
        }else {
            // 假如两个节点都找到了，那么这个自然就是他们的父节点了
            return root;
        }


    }
```





## [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

 

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。



```java
/**
     * 利用二叉搜索树的有序的特性  如果当前遍历的节点（root）.val > p和q的值  那么公共祖先一定在左子树上，如果都小的话，就一定在右子树上
     * @param root
     * @param p
     * @param q
     * @return
     */
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        if(root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
        if(root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
        return root;
    }
```





## [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

 

```java
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node.val + Math.max(leftGain, rightGain);
    }
}


```





## [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)



```java
public List<List<Integer>> levelOrder(Node root) {
        List<List<Integer>> list = new ArrayList<>();
        Deque<Node> que = new LinkedList<>();

        if (root == null) {
            return list;
        }

        que.offerLast(root);
        while (!que.isEmpty()) {
            int levelSize = que.size();
            List<Integer> levelList = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                Node poll = que.pollFirst();

                levelList.add(poll.val);

                List<Node> children = poll.children;
                if (children == null || children.size() == 0) {
                    continue;
                }
                for (Node child : children) {
                    if (child != null) {
                        que.offerLast(child);
                    }
                }
            }
            list.add(levelList);
        }

        return list;
    }

    class Node {
        public int val;
        public List<Node> children;

        public Node() {}

        public Node(int _val) {
            val = _val;
        }

        public Node(int _val, List<Node> _children) {
            val = _val;
            children = _children;
        }
    }
```







## [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```



**示例 2:**

```
输入：root = []
输出：[]
```



```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            // vector<int> vec;
            Node* nodePre;
            Node* node;
            for (int i = 0; i < size; i++) {
                if (i == 0) {
                    nodePre = que.front(); // 取出一层的头结点
                    que.pop();
                    node = nodePre;
                } else {
                    node = que.front();
                    que.pop();
                    nodePre->next = node; // 本层前一个节点next指向本节点
                    nodePre = nodePre->next;
                }
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            nodePre->next = NULL; // 本层最后一个节点指向NULL
        }
        return root;

    }
};
```

```java
/**
     * 本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了
     * 先连接，再加入
     * @param root
     * @return
     */
    public Node connect(Node root) {
       if(root == null){
           return root;
       }

       Queue<Node> queue = new LinkedList<>();
       queue.add(root);

       while (!queue.isEmpty()){
           int size = queue.size();

           for (int i = 0; i < size; i++) {
               Node node = queue.poll();
               // 连接
               if (i < size - 1) {
                   node.next = queue.peek();
               }

               // 拓展下一层节点
               if (node.left != null) {
                   queue.add(node.left);
               }
               if (node.right != null) {
                   queue.add(node.right);
               }
           }
       }

       return root;
    }
```







## [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```







```java
/**
     * 前后序遍历都可以
     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）
     */
    public TreeNode invertTree(TreeNode root) {
        if (root == null){
            return null;
        }

        swapChildren(root); // 中
        invertTree(root.left);  //左
        invertTree(root.right);  //右
        return root;
    }


    private void swapChildren(TreeNode root) {
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    }
```









## [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

 

**提示：**

- 树中节点的数目范围是`[0, 5 * 104]`
- `0 <= Node.val <= 5 * 104`
- 题目数据保证输入的树是 **完全二叉树**

 

**进阶：**遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？





法一：后序遍历

```java
/**
     * 先按照普通二叉树的方法来求  后序遍历  左右中
     * @param root
     * @return
     */
    public int countNodes(TreeNode root) {
        return getNodesNum(root);
    }

    public int getNodesNum(TreeNode root){
        if(root == null){
            return 0;
        }

        int leftSum = getNodesNum(root.left);       // 左
        int rightSum = getNodesNum(root.right);     // 右
        int treeNum = leftSum + rightSum + 1;       // 中
        return treeNum;
    }
```



法二：层序遍历

```java
/**
     * 层序遍历
     * @param root
     * @return
     */
    public int countNodes01(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        if(root != null){
            queue.add(root);
        }
        int result = 0;
        while (!queue.isEmpty()){
            int size = queue.size();

            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                result++;
                if(node.left != null){
                    queue.add(node.left);
                }
                if(node.right != null){
                    queue.add(node.right);
                }
            }
        }
        return result;
    }

```





法三：

```java
/**
     * 针对完全二叉树的解法
     *
     * 满二叉树的结点数为：2^depth - 1
     */
    public int countNodes02(TreeNode root) {
        if (root == null) return 0;
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftDepth = 0, rightDepth = 0; // 这里初始为0是有目的的，为了下面求指数方便
        while (left != null) {  // 求左子树深度
            left = left.left;
            leftDepth++;
        }
        while (right != null) { // 求右子树深度
            right = right.right;
            rightDepth++;
        }
        if (leftDepth == rightDepth) {
            return (2 << leftDepth) - 1; // 注意(2<<1) 相当于2^2，所以leftDepth初始为0
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
```







## [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是 

平衡二叉树

 



 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

**示例 3：**

```
输入：root = []
输出：true
```

 

**提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-104 <= Node.val <= 104`





此时大家应该明白了既然要求比较高度，必然是要后序遍历。

递归三步曲分析：

1. 明确递归函数的参数和返回值

参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

**那么如何标记左右子树是否差值大于1呢？**

**如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。**

**所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。**





```java
/**
     * 给定一个二叉树，判断它是否是平衡二叉树
     * 前序遍历
     * @param root
     * @return
     */
    public boolean isBalanced(TreeNode root) {
        return getHeight(root) != -1;
    }


    /**
     * 分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。
     * @param root
     * @return
     */
    int getHeight(TreeNode root){
        if(root == null){
            return 0;
        }

        // -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
        int leftHeight = getHeight(root.left);
        if (leftHeight == -1) {
            return -1;
        }

        int rightHeight = getHeight(root.right);
        if (rightHeight == -1) {
            return -1;
        }

        // 左右子树高度差大于1，return -1表示已经不是平衡树了
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }

        return Math.max(leftHeight, rightHeight) + 1;		// 最开始的是0 后面不断 +1

    }
```











## [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

 

**提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`





终止条件的确定

在写递归的时候都习惯了这么写：

```text
if (cur == NULL) {
    终止处理逻辑
}
```

但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。

**那么什么时候算是找到了叶子节点？** 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。

所以本题的终止条件是：

```text
if (cur->left == NULL && cur->right == NULL) {
    终止处理逻辑
}
```



```java
 List<String> result = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    /**
     * 二叉树的路径中，自然有些是要通过回溯来进行的
     * 同时，前序遍历
     * @param root
     * @return
     */
    public List<String> binaryTreePaths(TreeNode root) {
        backTracking(root);
        return result;
    }

    public void backTracking(TreeNode root){

        path.add(root.val); // 中

        // 遇到叶子节点,输出结果
        if(root.left == null && root.right == null){
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < path.size() - 1; i++) {     // 最后一个节点是没有 ->的
                sb.append(path.get(i)).append("->");        // 构造输出结果
            }
            sb.append(path.get(path.size() - 1));// 记录最后一个节点
            result.add(sb.toString());
            return;
        }
        
        // 递归和回溯同时进行
        if(root.left != null){
            backTracking(root.left);    // 左
            path.remove(path.size() - 1);    //把最后一个回退出来
        }
        
        if(root.right != null){     // 右
            backTracking(root.right);
            path.remove(path.size() - 1);    //把最后一个回退出来
        }
    }
```









## [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* ***最大二叉树\*** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**







```java
/**
     * 前序遍历构造
     *
     * 终止条件：当递归遍历的时候，如果传入的数组大小为1，说明遍历到了叶子节点了。
     * 那么应该定义一个新的节点，并把这个数组的数值赋给新的节点，然后返回这个节点。 这表示一个数组大小是1的时候，构造了一个新的节点，并返回。
     * @param nums
     * @return
     */
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return buildTree(nums,0, nums.length);
    }


    public TreeNode buildTree(int[] nums,int leftIndex,int rightIndex){
        //没有元素了
        if(rightIndex - leftIndex < 1){
            return null;
        }

        // 只剩下一个元素
        if(rightIndex - leftIndex == 1){
            return new TreeNode(nums[leftIndex]);
        }

        // 假如数组范围中还剩下其他元素，那么就要找到最大值和最大的下标，然后进行分割
        int maxIndex = leftIndex;
        int maxValue = nums[leftIndex];   // 初始化

        for (int i = leftIndex + 1; i < rightIndex; i++) {
            if(nums[i] > maxValue){
                maxValue = nums[i];
                maxIndex = i;
            }
        }

        TreeNode node = new TreeNode(maxValue);
        node.left = buildTree(nums, leftIndex, maxIndex);
        node.right = buildTree(nums,maxIndex + 1,rightIndex);
        return node;
    }
```







## [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)



给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)

```
输入：root = [1,null,2,2]
输出：[2]
```

**示例 2：**

```
输入：root = [0]
输出：[0]
```

 

**提示：**

- 树中节点的数目在范围 `[1, 104]` 内
- `-105 <= Node.val <= 105`

 



法一：

```java
**
     * 假如当作个普通的二叉树来看，什么样的遍历顺序都行，然后用个map统计然后排序，最后放入集合中
     * @param root
     * @return
     */
    public int[] findMode(TreeNode root) {
        if(root == null) return new int[0];

        HashMap<Integer, Integer> map = new HashMap<>();
        inorderTraversal(root,map);

        // 要对map按照value排序  然后返回结果

        ArrayList<Map.Entry<Integer, Integer>> list = new ArrayList<>();

        Collections.sort(list, new Comparator<Map.Entry<Integer, Integer>>() {
            @Override
            public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
                // 前面 - 后面  升序
                // 后面 - 前面  降序
                return o2.getValue() - o1.getValue();
            }
        });

        // 最大出现的次数
        int maxCount = list.get(0).getValue();

        // 遍历map

        List<Integer> modes = new ArrayList<>();
        for (Map.Entry<Integer, Integer> entry : list) {
            if(entry.getValue() == maxCount){
                modes.add(entry.getKey());
            }else {
                break;      // 因为已经按照降序排列，遇到次数小于最大出现次数的节点值时，可以直接结束循环
            }
        }

        // 将结果列表转换为数组
        int[] result = new int[modes.size()];
        for (int i = 0; i < modes.size(); i++) {
            result[i] = modes.get(i);
        }

        return result;
    }

    private void inorderTraversal(TreeNode root, Map<Integer,Integer> map){
        if(root == null) return;

        inorderTraversal(root.left,map);    //左
        map.put(root.val,map.getOrDefault(root.val,0) + 1);
        inorderTraversal(root.right,map);
    }
```





法二：用二叉搜索树的特性





**遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。**

* 关键是在有序数组上的话，好搞，在树上怎么搞呢？
* 这就考察对树的操作了。
* 在二叉树：搜索树的最小绝对差 (opens new window)中我们就**使用了pre指针和cur指针的技巧，这次又用上了。**
* **弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。**
* **而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。**

```java
private int maxCount = 0;
    private int currentCount = 0;
    private TreeNode preNode = null;
    /**
     * 遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。
     * 关键是在有序数组上的话，好搞，在树上怎么搞呢？
     * 这就考察对树的操作了。
     * 在二叉树：搜索树的最小绝对差 (opens new window)中我们就使用了pre指针和cur指针的技巧，这次又用上了。
     * 弄一个指针指向前一个节点，这样每次cur（当前节点）才能和pre（前一个节点）作比较。
     * 而且初始化的时候pre = NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。
     */
    // 存储结果的列表
    private List<Integer> modes = new ArrayList<>();


    /**
     * 利用二叉搜索树的中序遍历
     * @param root
     * @return
     */
    public int[] findMode01(TreeNode root) {
        traversal(root);
        int[] result = new int[modes.size()];
        for (int i = 0; i < result.length; i++) {
            result[i] = modes.get(i);
        }
        return result;
    }


    private void traversal(TreeNode root){
        if(root == null) return;

        traversal(root.left);       // 左

        if(preNode != null && preNode.val == root.val){
            currentCount++;
        }else {
            currentCount = 1;
        }

        if(currentCount > maxCount){
            maxCount = currentCount;
            modes.clear();      // 有更多的数，先清空，在更新
            modes.add(root.val);
        } else if (currentCount == maxCount) {
            modes.add(root.val);        // 有多个重复的值
        }

        preNode = root;
        traversal(root.right);
    }

```





## 小总结

- 涉及到**二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。**
- 求**普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。**
- 求**二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。**

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.二叉树的所有路径.html)也用了前序，这是为了方便让父节点指向子节点。

