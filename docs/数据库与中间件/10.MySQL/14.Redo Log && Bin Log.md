---
title: Redo Log && Bin Log
date: 2023-12-20 15:02:57
permalink: /pages/8186e9/
categories:
  - 数据库与中间件
  - MySQL
tags:
  - 
---
# Redo Log && Bin Log



看MySQL 45讲的时候经常看见这两个，总是懵懵懂懂，来个总结先。具体的可以看`MySQL 02 日志系统：一条SQL更新语句是如何执行的？`









1. **Redo Log（重做日志）：**
   - **作用：** Redo Log是用于保证事务的持久性（Durability）的一种机制。当一个事务提交时，其所做的修改会首先写入重做日志，然后再写入磁盘上的数据库表。这样，在数据库发生故障时，可以通过重做日志来重新执行事务的修改，以保证数据库的一致性。
   - **特点：** Redo Log是循环写的，它是一个固定大小的循环缓冲区，循环使用，确保记录了最近的事务修改。

2. **Binary Log（二进制日志）：**
   - **作用：** Binary Log用于数据库复制（replication）。它记录了对数据库的所有修改操作，包括插入、更新和删除等。通过将Binary Log从主数据库传输到从数据库，可以在从数据库上重放主数据库上的所有修改操作，实现数据复制。
   - **特点：** Binary Log是线性写的，它记录了数据库中所有的修改操作，以便从服务器能够按照相同的顺序重演这些修改。它还可以用于恢复，但相较于Redo Log，它并不是用于崩溃恢复的主要工具。



redo log 与 binlog 有以下**三点不同**：

1. redo log 是 InnoDB 引擎特有的；**binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。**
2. **redo log 是物理日志**，记录的是“在某个数据页上做了什么修改”；**binlog 是逻辑日志**，**记录的是这个语句的原始逻辑**，比如“给 ID=2 这一行的 c 字段加 1 ”。
3. redo log 是**循环写的**，空间固定会用完；binlog 是可以**追加写入的**。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。





有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程：

1. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在**内存 cache**中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 **redo log 处于 prepare 状态**。然后告知执行器执行完成了，随时可以提交事务。
4. **执行器生成这个操作的 binlog，并把 binlog 写入磁盘。**
5. 执行器调用引擎的提交事务接口，**引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。**

下面给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。

![image-20230117213746509](https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230117213746509.png)



**将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是"两阶段提交"。**





