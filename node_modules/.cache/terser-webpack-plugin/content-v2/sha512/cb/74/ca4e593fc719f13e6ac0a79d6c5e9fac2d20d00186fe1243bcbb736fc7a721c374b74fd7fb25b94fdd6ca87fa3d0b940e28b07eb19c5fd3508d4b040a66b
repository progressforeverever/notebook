{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{522:function(t,s,_){\"use strict\";_.r(s);var v=_(4),a=Object(v.a)({},(function(){var t=this,s=t._self._c;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"_4-6-如何理解是-tcp-面向字节流协议\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-6-如何理解是-tcp-面向字节流协议\"}},[t._v(\"#\")]),t._v(\" 4.6 如何理解是 TCP 面向字节流协议？\")]),t._v(\" \"),s(\"p\",[t._v(\"有个读者问我，这么个问题：\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"TCP 是面向字节流的协议，UDP 是面向报文的协议？这里的「面向字节流」和「面向报文」该如何理解。\")])]),t._v(\" \"),s(\"hr\"),t._v(\" \"),s(\"h2\",{attrs:{id:\"如何理解字节流\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何理解字节流\"}},[t._v(\"#\")]),t._v(\" 如何理解字节流？\")]),t._v(\" \"),s(\"p\",[t._v(\"之所以会说 TCP 是面向字节流的协议，UDP 是面向报文的协议，是因为操作系统对 TCP 和 UDP 协议的\"),s(\"strong\",[t._v(\"发送方的机制不同\")]),t._v(\"，也就是问题原因在发送方。\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"先来说说为什么 UDP 是面向报文的协议？\")])]),t._v(\" \"),s(\"p\",[t._v(\"当用户消息通过 \"),s(\"strong\",[t._v(\"UDP 协议传输时\")]),t._v(\"，\"),s(\"strong\",[t._v(\"操作系统不会对消息进行拆分\")]),t._v(\"，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是\"),s(\"strong\",[t._v(\"每个 UDP 报文就是一个用户消息的边界\")]),t._v(\"，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。\")]),t._v(\" \"),s(\"p\",[t._v(\"你可能会问，如果收到了两个 UDP 报文，操作系统是怎么区分开的？\")]),t._v(\" \"),s(\"p\",[t._v(\"操作系统在收到 UDP 报文后，会将其插入到队列里，\"),s(\"strong\",[t._v(\"队列里的每一个元素就是一个 UDP 报文\")]),t._v(\"，这样当用户调用 recvfrom() 系统调用读数据的时候，就会从队列里取出一个数据，然后从内核里拷贝给用户缓冲区。\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/img_convert/a9116c5b375d356048df033dcb53582e.png\",alt:\"图片\"}})]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"再来说说为什么 TCP 是面向字节流的协议？\")])]),t._v(\" \"),s(\"p\",[t._v(\"当用户消息通过 \"),s(\"strong\",[t._v(\"TCP 协议传输时\")]),t._v(\"，\"),s(\"strong\",[t._v(\"消息可能会被操作系统分组成多个的 TCP 报文\")]),t._v(\"，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。\")]),t._v(\" \"),s(\"p\",[t._v(\"这时，接收方的程序如果不知道发送方发送的消息的长度，\"),s(\"strong\",[t._v(\"也就是不知道消息的边界时，是无法读出一个有效的用户消息的\")]),t._v(\"，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。\")]),t._v(\" \"),s(\"p\",[t._v(\"举个实际的例子来说明。\")]),t._v(\" \"),s(\"p\",[t._v(\"发送方准备发送「Hi.」和「I am Xiaolin」这两个消息。\")]),t._v(\" \"),s(\"p\",[t._v(\"在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，\"),s(\"strong\",[t._v(\"只是从应用程序拷贝到了操作系统内核协议栈中。\")])]),t._v(\" \"),s(\"p\",[t._v(\"至于什么时候真正被发送，\"),s(\"strong\",[t._v(\"取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件\")]),t._v(\"。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。\")]),t._v(\" \"),s(\"p\",[t._v(\"如果我们考虑实际网络传输过程中的各种影响，假设发送端陆续调用 send 函数先后发送「Hi.」和「I am Xiaolin」报文，那么实际的发送很有可能是这几种情况。\")]),t._v(\" \"),s(\"p\",[t._v(\"第一种情况，这两个消息被分到同一个 TCP 报文，像这样：\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/img_convert/02dce678f870c8c70482b6e37dbb5574.png\",alt:\"图片\"}})]),t._v(\" \"),s(\"p\",[t._v(\"第二种情况，「I am Xiaolin」的部分随「Hi」在一个 TCP 报文中发送出去，像这样：\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/img_convert/f58b70cde860188b8f95a433e2f5293b.png\",alt:\"图片\"}})]),t._v(\" \"),s(\"p\",[t._v(\"第三种情况，「Hi.」的一部分随 TCP 报文被发送出去，另一部分和「I am Xiaolin」一起随另一个 TCP 报文发送出去，像这样。\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/img_convert/68080e783d7acc842fa254e4f9ec5630.png\",alt:\"图片\"}})]),t._v(\" \"),s(\"p\",[t._v(\"类似的情况还能举例很多种，这里主要是想说明，我们不知道「Hi.」和「I am Xiaolin」这两个用户消息是如何进行 TCP 分组传输的。\")]),t._v(\" \"),s(\"p\",[t._v(\"因此，\"),s(\"strong\",[t._v(\"我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议\")]),t._v(\"。\")]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。\")])]),t._v(\" \"),s(\"p\",[t._v(\"要解决这个问题，要交给\"),s(\"strong\",[t._v(\"应用程序\")]),t._v(\"。\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"如何解决粘包\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何解决粘包\"}},[t._v(\"#\")]),t._v(\" 如何解决粘包？\")]),t._v(\" \"),s(\"p\",[t._v(\"粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。\")]),t._v(\" \"),s(\"p\",[t._v(\"一般有三种方式分包的方式：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[s(\"strong\",[t._v(\"固定长度的消息\")]),t._v(\"；\")]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"特殊字符作为边界；\")])]),t._v(\" \"),s(\"li\",[s(\"strong\",[t._v(\"自定义消息结构。\")])])]),t._v(\" \"),s(\"h4\",{attrs:{id:\"固定长度的消息\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#固定长度的消息\"}},[t._v(\"#\")]),t._v(\" 固定长度的消息\")]),t._v(\" \"),s(\"p\",[t._v(\"这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。\")]),t._v(\" \"),s(\"p\",[t._v(\"但是这种方式灵活性不高，实际中很少用。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"特殊字符作为边界\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#特殊字符作为边界\"}},[t._v(\"#\")]),t._v(\" 特殊字符作为边界\")]),t._v(\" \"),s(\"p\",[t._v(\"我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。\")]),t._v(\" \"),s(\"p\",[t._v(\"HTTP 是一个非常好的例子。\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://img-blog.csdnimg.cn/img_convert/a49a6bb8cd38ae1738d9c00aec68b444.png\",alt:\"图片\"}})]),t._v(\" \"),s(\"p\",[t._v(\"HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。\")]),t._v(\" \"),s(\"p\",[t._v(\"有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"自定义消息结构\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自定义消息结构\"}},[t._v(\"#\")]),t._v(\" 自定义消息结构\")]),t._v(\" \"),s(\"p\",[t._v(\"我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。\")]),t._v(\" \"),s(\"p\",[t._v(\"比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-c line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-c\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"struct\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"{\")]),t._v(\" \\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[t._v(\"u_int32_t\")]),t._v(\" message_length\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \\n    \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"char\")]),t._v(\" message_data\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"[\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"]\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\" \\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"}\")]),t._v(\" message\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\")])]),s(\"p\",[t._v(\"当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。\")])])}),[],!1,null,null,null);s.default=a.exports}}]);","extractedComments":[]}