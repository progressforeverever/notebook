{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{448:function(s,i,e){\"use strict\";e.r(i);var v=e(4),_=Object(v.a)({},(function(){var s=this,i=s._self._c;return i(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[i(\"h1\",{attrs:{id:\"redis面试题\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis面试题\"}},[s._v(\"#\")]),s._v(\" Redis面试题\")]),s._v(\" \"),i(\"h2\",{attrs:{id:\"讲一下-redis-的单线程模型-io-多路复用是什么\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#讲一下-redis-的单线程模型-io-多路复用是什么\"}},[s._v(\"#\")]),s._v(\" 讲⼀下 Redis 的单线程模型，IO 多路复⽤是什么？\")]),s._v(\" \"),i(\"p\",[s._v(\"Redis 是⼀款基于内存的⾼性能键值存储系统，\"),i(\"strong\",[s._v(\"采⽤单线程模型的设计。\")])]),s._v(\" \"),i(\"p\",[s._v(\"在 Redis 中，\"),i(\"strong\",[s._v(\"所有客户端的请求都是由⼀个单线程来处理的，这个单线程不断地从客户端套接字中读取命令请求， 并将命令请求放⼊⼀个请求队列中\")]),s._v(\"。接着，Redis 的事件处理器会\"),i(\"strong\",[s._v(\"按照⼀定的规则选择⼀个请求进⾏处理，处理完之后将响应结果返回给客户端\")]),s._v(\"。 单线程模型的优点是\"),i(\"strong\",[s._v(\"可以避免多线程并发访问共享数据时的竞争和死锁问题，简化了系统的设计和调试\")]),s._v(\"。此外，由于 Redis 的内存访问速度⾮常快，因此单线程处理请求也能够保证⾜够的性能。\")]),s._v(\" \"),i(\"p\",[i(\"strong\",[s._v(\"IO 多路复⽤是指在⼀个线程中同时监听多个⽂件描述符，⼀旦某个⽂件描述符就绪，就⽴即处理对应的事件\")]),s._v(\"。在 Redis 中，采⽤的是基于 epoll 的 IO 多路复⽤技术，可以实现⾼效的事件监听和响应。 在 Redis 中，客户端的请求是由⼀个单线程来处理的，⽽ IO 操作却是通过 epoll 多路复⽤技 术实现的。这种设计⽅式既能充分利⽤ CPU 的计算能⼒，⼜能够保证⾜够的 IO 处理能⼒， 从⽽实现了⾼效的键值存储服务\")]),s._v(\" \"),i(\"h2\",{attrs:{id:\"redis-基础类型中的-string-底层实现是什么\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-基础类型中的-string-底层实现是什么\"}},[s._v(\"#\")]),s._v(\" Redis 基础类型中的 String 底层实现是什么？\")]),s._v(\" \"),i(\"p\",[s._v(\"// TODO\")]),s._v(\" \"),i(\"h2\",{attrs:{id:\"如何使用-redis-实现一个排行榜\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何使用-redis-实现一个排行榜\"}},[s._v(\"#\")]),s._v(\" 如何使⽤ Redis 实现⼀个排⾏榜？\")]),s._v(\" \"),i(\"p\",[s._v(\"使⽤ Redis 可以很⽅便地实现⼀个排⾏榜，以下是⼀种实现⽅法： \"),i(\"strong\",[s._v(\"使⽤有序集合（Sorted Set）来存储排⾏榜数据\")]),s._v(\"，\"),i(\"strong\",[s._v(\"以⽤户得分作为分数(score)，⽤户 ID 作为 成员(member)。\")])]),s._v(\" \"),i(\"p\",[s._v(\"当⽤户得分改变时，使⽤ Redis 的 \"),i(\"strong\",[s._v(\"ZADD 命令将⽤户的分数更新到有序集合中\")]),s._v(\"。 获取排⾏榜数据时，\"),i(\"strong\",[s._v(\"使⽤ Redis 的 ZREVRANGE 命令按分数倒序获取有序集合中的成员。 可以使⽤ Redis 的 ZSCORE 命令获取某个⽤户的分数，或使⽤ ZREVRANK 命令获取某个⽤ 户的排名\")])]),s._v(\" \"),i(\"h2\",{attrs:{id:\"redis持久化机制\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis持久化机制\"}},[s._v(\"#\")]),s._v(\" Redis持久化机制\")]),s._v(\" \"),i(\"p\",[s._v(\"//TODO\")]),s._v(\" \"),i(\"h2\",{attrs:{id:\"redis内存淘汰机制\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis内存淘汰机制\"}},[s._v(\"#\")]),s._v(\" Redis内存淘汰机制\")]),s._v(\" \"),i(\"p\",[s._v(\"Redis 是⼀种基于内存的键值数据库，由于内存有限，当 Redis 占⽤的内存达到上限时，就需 要进⾏内存淘汰，以腾出⼀些内存空间。 Redis 中的内存淘汰机制包括：\")]),s._v(\" \"),i(\"ol\",[i(\"li\",[i(\"p\",[s._v(\"定期删除：Redis 可以设置⼀个定时器，定期扫描键空间中的键，并删除已经过期的键。\")])]),s._v(\" \"),i(\"li\",[i(\"p\",[s._v(\"惰性删除：当⼀个键过期时，Redis 不会⽴即删除该键，⽽是等到该键被访问时再删除。\")])]),s._v(\" \"),i(\"li\",[i(\"p\",[s._v(\"内存淘汰策略：当 Redis 内存占⽤达到上限时，会根据内存淘汰策略来选择⼀些键进⾏删 除，以腾出更多的内存空间。\")])])]),s._v(\" \"),i(\"p\",[s._v(\"Redis 中的内存淘汰策略包括：\")]),s._v(\" \"),i(\"ol\",[i(\"li\",[i(\"p\",[s._v(\"noeviction：禁⽌删除键，即不做任何操作。\")])]),s._v(\" \"),i(\"li\",[i(\"p\",[i(\"strong\",[s._v(\"allkeys-lru：从所有的键中选择最近最少使⽤的键进⾏删除。\")])])]),s._v(\" \"),i(\"li\",[i(\"p\",[i(\"strong\",[s._v(\"allkeys-random：从所有的键中随机选择⼀些键进⾏删除。\")])])]),s._v(\" \"),i(\"li\",[i(\"p\",[i(\"strong\",[s._v(\"volatile-lru：从已设置过期时间的键中选择最近最少使⽤的键进⾏删除。\")])])]),s._v(\" \"),i(\"li\",[i(\"p\",[i(\"strong\",[s._v(\"volatile-random：从已设置过期时间的键中随机选择⼀些键进⾏删除。\")])])]),s._v(\" \"),i(\"li\",[i(\"p\",[i(\"strong\",[s._v(\"volatile-ttl：从已设置过期时间的键中选择剩余时间最短的键进⾏删除。\")])])])]),s._v(\" \"),i(\"p\",[s._v(\"其中，noeviction 策略是最简单的策略，但可能会导致 Redis 内存占满，并导致 Redis ⽆法正 常⼯作。其他策略则会根据不同的算法进⾏键的选择和删除，以尽可能地保留重要的键。 总之，Redis 中的内存淘汰机制是保证 Redis 正常运⾏的重要机制之⼀，内存淘汰策略则根据 不同的场景选择合适的策略来删除不必要的键，以腾出更多的内存空间\")]),s._v(\" \"),i(\"h2\",{attrs:{id:\"redis-为什么快\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis-为什么快\"}},[s._v(\"#\")]),s._v(\" Redis 为什么快？\")]),s._v(\" \"),i(\"p\",[s._v(\"Redis 之所以快，主要有以下⼏个⽅⾯的原因：\")]),s._v(\" \"),i(\"ol\",[i(\"li\",[s._v(\"内存存储：Redis 的数据都是存储在内存中的，相⽐于硬盘存储的数据库，内存存储速度 更快。\")]),s._v(\" \"),i(\"li\",[s._v(\"单线程模型：Redis 使⽤单线程模型处理所有的请求，避免了多线程之间的线程切换和竞 争等开销，提⾼了处理请求的效率。 3.\")]),s._v(\" \"),i(\"li\",[s._v(\"⾮阻塞 I/O：Redis 使⽤⾮阻塞 I/O 处理⽹络通信，当⼀个客户端请求到来时，Redis 不 会⼀直等待客户端的响应，⽽是会先处理其它的请求，这样就避免了 I/O 阻塞带来的性能 问题。\")]),s._v(\" \"),i(\"li\",[s._v(\"精简⾼效的数据结构：Redis 内置了多种⾼效的数据结构，如哈希表、跳表等，这些数据 结构的实现⾮常精简⾼效，减少了 Redis 对内存和 CPU 的占⽤，从⽽提⾼了 Redis 的性 能。\")]),s._v(\" \"),i(\"li\",[s._v(\"持久化策略：Redis ⽀持多种持久化策略，如 RDB（快照）和 AOF（追加式⽂件）等， 这些策略可以将内存中的数据保存到硬盘中，以保证数据的持久性和安全性。同时， Redis 可以将数据以压缩的⽅式存储在硬盘中，减少了硬盘的占⽤，提⾼了数据的读写速 度\")])]),s._v(\" \"),i(\"h2\",{attrs:{id:\"redis实现分布式锁\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redis实现分布式锁\"}},[s._v(\"#\")]),s._v(\" Redis实现分布式锁\")]),s._v(\" \"),i(\"p\",[s._v(\"redis 实现分布式锁\")]),s._v(\" \"),i(\"ol\",[i(\"li\",[s._v(\"redis 实现分布式锁的⽅式有两种：\")]),s._v(\" \"),i(\"li\",[s._v(\"通过 \"),i(\"strong\",[s._v(\"redis 提供的 setnx 进⾏实现，往 redis 中使⽤ setnx 插⼊ key 时，如果 key 存在， 则返回 0，可以通过插⼊ key 的返回值进⾏判断来实现分布式锁\")])]),s._v(\" \"),i(\"li\",[s._v(\"通过使⽤ Redission（客户端）来实现分布式锁。可以调⽤ Redission 提供的 api，即 lock()，unlock()⽅法进⾏加锁和锁的释放。此外， \"),i(\"strong\",[s._v(\"Redission 还提供了 watchdog，即看⻔狗，来对加锁的 key 每隔 10 s对该 key 进⾏续时，（从⽽避免锁的过期）\")])]),s._v(\" \"),i(\"li\",[s._v(\"Redission 的所有指令是通过 lua 脚本进⾏实现的，lua 脚本可以保证所有指令执⾏的原⼦ 性\")]),s._v(\" \"),i(\"li\",[s._v(\"关键词：\"),i(\"strong\",[s._v(\"setnx，Redission，lock，unlock，watchdog，lua，原⼦性\")])])])])}),[],!1,null,null,null);i.default=_.exports}}]);","extractedComments":[]}