{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{361:function(s,a,t){\"use strict\";t.r(a);var n=t(4),r=Object(n.a)({},(function(){var s=this,a=s._self._c;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"serializable接口\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#serializable接口\"}},[s._v(\"#\")]),s._v(\" Serializable接口\")]),s._v(\" \"),a(\"p\",[s._v(\"Java对象序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。\"),a(\"strong\",[s._v(\"对象序列化是对象持久化的一种实现方法\")]),s._v(\"，它是将对象的属性和方法转化为一种序列化的形式用于\"),a(\"strong\",[s._v(\"存储和传输\")]),s._v(\"。反序列化就是根据这些保存的信息\"),a(\"strong\",[s._v(\"重建对象\")]),s._v(\"的过程。\")]),s._v(\" \"),a(\"ul\",[a(\"li\",[s._v(\"序列化：将Java对象转化为字节序列的过程。\")]),s._v(\" \"),a(\"li\",[s._v(\"反序列化：将字节序列转化为Java对象的过程。\")])]),s._v(\" \"),a(\"p\",[s._v(\"我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。那么当两个Java进程进行通信时，能否实现进程间的\"),a(\"strong\",[s._v(\"对象传送\")]),s._v(\"呢？答案是可以的。如何做到呢？\")]),s._v(\" \"),a(\"p\",[s._v(\"这就需要Java序列化与反序列化了。换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。\\n当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了\"),a(\"strong\",[s._v(\"数据的持久化\")]),s._v(\"，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现\"),a(\"strong\",[s._v(\"远程通信\")]),s._v(\"，即在网络上传送对象的字节序列。\")]),s._v(\" \"),a(\"div\",{staticClass:\"language-java line-numbers-mode\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-java\"}},[a(\"code\",[a(\"span\",{pre:!0,attrs:{class:\"token annotation punctuation\"}},[s._v(\"@Data\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"public\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"class\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"Person\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"implements\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"Serializable\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[s._v(\"//序列化ID\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"private\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"static\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"final\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"long\")]),s._v(\" serialVersionUID \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"=\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\"-\")]),a(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"5809782578272943999L\")]),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n \\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"private\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"int\")]),s._v(\" id\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"private\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token class-name\"}},[s._v(\"String\")]),s._v(\" name\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n    \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"private\")]),s._v(\" \"),a(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[s._v(\"int\")]),s._v(\" age\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\";\")]),s._v(\"\\n\"),a(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\")])]),s._v(\" \"),a(\"div\",{staticClass:\"line-numbers-wrapper\"},[a(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"7\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"8\")]),a(\"br\"),a(\"span\",{staticClass:\"line-number\"},[s._v(\"9\")]),a(\"br\")])]),a(\"p\",[s._v(\"我们在代码里会发现有这样一个变量：serialVersionUID，那么这个变量serialVersionUID到底具有什么作用呢？能不能去掉呢？\")]),s._v(\" \"),a(\"p\",[s._v(\"其实，这个序列化ID起着关键的作用，它\"),a(\"strong\",[s._v(\"决定着是否能够成功反序列化\")]),s._v(\"！简单来说，Java的序列化机制是通过在\"),a(\"strong\",[s._v(\"运行时判断类的serialVersionUID来验证版本一致性的\")]),s._v(\"。在进行反序列化时，JVM会把传来的\"),a(\"strong\",[s._v(\"字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较\")]),s._v(\"，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。\")]),s._v(\" \"),a(\"p\",[s._v(\"当我们一个实体类中\"),a(\"strong\",[s._v(\"没有显示的定义一个名为“serialVersionUID”\")]),s._v(\"、类型为long的变量时，Java序列化机制会根据编译时的class\"),a(\"strong\",[s._v(\"自动生成\")]),s._v(\"一个serialVersionUID作为序列化版本比较，这种情况下，只有\"),a(\"strong\",[s._v(\"同一次编译生成的class才会生成相同的serialVersionUID\")]),s._v(\"。譬如，当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在\"),a(\"strong\",[s._v(\"本地类中添加其他的字段，这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败\")]),s._v(\"。那么如何解决呢？便是在本地类中添加一个**“serialVersionUID”变量，值保持不变，便可以进行序列化和反序列化。**\")]),s._v(\" \"),a(\"p\",[s._v(\"虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID = 1L）。\")]),s._v(\" \"),a(\"p\",[s._v(\"开坑IO流.....\")]),s._v(\" \"),a(\"p\",[s._v(\"上！！！\")])])}),[],!1,null,null,null);a.default=r.exports}}]);","extractedComments":[]}