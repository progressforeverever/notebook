{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{452:function(_,s,v){\"use strict\";v.r(s);var t=v(4),a=Object(t.a)({},(function(){var _=this,s=_._self._c;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":_.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"锁\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#锁\"}},[_._v(\"#\")]),_._v(\" 锁\")]),_._v(\" \"),s(\"p\",[_._v(\"在 MySQL 里，根据加锁的范围，可以分为\"),s(\"strong\",[_._v(\"全局锁、表级锁和行锁\")]),_._v(\"三类。\")]),_._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://cdn.xiaolincoding.com//mysql/other/1e37f6994ef44714aba03b8046b1ace2.png\",alt:\"img\"}})]),_._v(\" \"),s(\"h2\",{attrs:{id:\"全局锁\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#全局锁\"}},[_._v(\"#\")]),_._v(\" 全局锁\")]),_._v(\" \"),s(\"p\",[_._v(\"要使用全局锁，则要执行这条命令：\")]),_._v(\" \"),s(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[s(\"code\",[_._v(\"flush \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"tables\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"with\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"read\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"lock\")]),_._v(\"\\n\")])]),_._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[_._v(\"1\")]),s(\"br\")])]),s(\"p\",[_._v(\"执行后，\"),s(\"strong\",[_._v(\"整个数据库就处于只读状态了\")]),_._v(\"，这时其他线程执行以下操作，都会被阻塞：\")]),_._v(\" \"),s(\"ul\",[s(\"li\",[_._v(\"对数据的增删改操作，比如 insert、delete、update等语句；\")]),_._v(\" \"),s(\"li\",[_._v(\"对表结构的更改操作，比如 alter table、drop table 等语句。\")])]),_._v(\" \"),s(\"p\",[_._v(\"如果要释放全局锁，则要执行这条命令：\")]),_._v(\" \"),s(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"unlock\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"tables\")]),_._v(\"\\n\")])]),_._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[_._v(\"1\")]),s(\"br\")])]),s(\"p\",[_._v(\"当然，当会话断开了，全局锁会被自动释放。\")]),_._v(\" \"),s(\"p\",[_._v(\"全局锁主要应用于做\"),s(\"strong\",[_._v(\"全库逻辑备份\")]),_._v(\"，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。\")]),_._v(\" \"),s(\"p\",[_._v(\"加上全局锁，\"),s(\"strong\",[_._v(\"意味着整个数据库都是只读状态。\")])]),_._v(\" \"),s(\"p\",[_._v(\"那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。\")]),_._v(\" \"),s(\"blockquote\",[s(\"p\",[_._v(\"既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？\")])]),_._v(\" \"),s(\"p\",[_._v(\"有的，如果数据库的引擎支持的事务支持\"),s(\"strong\",[_._v(\"可重复读的隔离级别\")]),_._v(\"，那么在备份数据库之前\"),s(\"strong\",[_._v(\"先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View\")]),_._v(\"，而且由于 \"),s(\"strong\",[_._v(\"MVCC 的支持，备份期间业务依然可以对数据进行更新操作。\")])]),_._v(\" \"),s(\"p\",[_._v(\"因为在可重复读的隔离级别下，即使其他事务更新了表的数据，\"),s(\"strong\",[_._v(\"也不会影响备份数据库时的 Read View\")]),_._v(\"，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。\")]),_._v(\" \"),s(\"p\",[s(\"strong\",[_._v(\"备份数据库的工具是 mysqldump\")]),_._v(\"，在使用 mysqldump 时加上 \"),s(\"code\",[_._v(\"–single-transaction\")]),_._v(\" 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。\")]),_._v(\" \"),s(\"p\",[s(\"strong\",[_._v(\"InnoDB 存储引擎默认的事务隔离级别正是可重复读\")]),_._v(\"，因此可以采用这种方式来备份数据库。\")]),_._v(\" \"),s(\"p\",[_._v(\"但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法\")]),_._v(\" \"),s(\"p\",[_._v(\"表级锁\")]),_._v(\" \"),s(\"h2\",{attrs:{id:\"表锁\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#表锁\"}},[_._v(\"#\")]),_._v(\" 表锁\")]),_._v(\" \"),s(\"p\",[_._v(\"先来说说\"),s(\"strong\",[_._v(\"表锁\")]),_._v(\"。\")]),_._v(\" \"),s(\"p\",[_._v(\"如果我们想对学生表（t_student）加表锁，可以使用下面的命令：\")]),_._v(\" \"),s(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[_._v(\"//表级别的共享锁，也就是读锁；\")]),_._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"lock\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"tables\")]),_._v(\" t_student \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"read\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\";\")]),_._v(\"\\n\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token comment\"}},[_._v(\"//表级别的独占锁，也就是写锁；\")]),_._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"lock\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"tables\")]),_._v(\" t_stuent \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"write\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[_._v(\";\")]),_._v(\"\\n\")])]),_._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[_._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[_._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[_._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[_._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[_._v(\"5\")]),s(\"br\")])]),s(\"p\",[_._v(\"需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。\")]),_._v(\" \"),s(\"p\",[_._v(\"也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，\"),s(\"strong\",[_._v(\"当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。\")])]),_._v(\" \"),s(\"p\",[_._v(\"要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：\")]),_._v(\" \"),s(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"unlock\")]),_._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[_._v(\"tables\")]),_._v(\"\\n\")])]),_._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[_._v(\"1\")]),s(\"br\")])]),s(\"p\",[_._v(\"另外，当会话退出后，也会释放所有表锁。\")]),_._v(\" \"),s(\"p\",[_._v(\"不过\"),s(\"strong\",[_._v(\"尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能\")]),_._v(\"，\"),s(\"strong\",[_._v(\"InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁\")]),_._v(\"。\")]),_._v(\" \"),s(\"h2\",{attrs:{id:\"元数据锁\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#元数据锁\"}},[_._v(\"#\")]),_._v(\" 元数据锁\")]),_._v(\" \"),s(\"p\",[_._v(\"再来说说\"),s(\"strong\",[_._v(\"元数据锁\")]),_._v(\"（MDL）。\")]),_._v(\" \"),s(\"p\",[_._v(\"我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：\")]),_._v(\" \"),s(\"ul\",[s(\"li\",[_._v(\"对一张表进行 CRUD 操作时，加的是 \"),s(\"strong\",[_._v(\"MDL 读锁\")]),_._v(\"；\")]),_._v(\" \"),s(\"li\",[_._v(\"对一张表做结构变更操作的时候，加的是 \"),s(\"strong\",[_._v(\"MDL 写锁\")]),_._v(\"；\")])]),_._v(\" \"),s(\"p\",[_._v(\"MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。\")]),_._v(\" \"),s(\"p\",[_._v(\"当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。\")]),_._v(\" \"),s(\"p\",[_._v(\"反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。\")]),_._v(\" \"),s(\"blockquote\",[s(\"p\",[_._v(\"MDL 不需要显示调用，那它是在什么时候释放的?\")])]),_._v(\" \"),s(\"p\",[s(\"strong\",[_._v(\"MDL 是在事务提交后才会释放\")]),_._v(\"，这意味着\"),s(\"strong\",[_._v(\"事务执行期间，MDL 是一直持有的\")]),_._v(\"。\")]),_._v(\" \"),s(\"p\",[_._v(\"那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：\")]),_._v(\" \"),s(\"ol\",[s(\"li\",[_._v(\"首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；\")]),_._v(\" \"),s(\"li\",[_._v(\"然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，\"),s(\"strong\",[_._v(\"因为「读读」并不冲突；\")])]),_._v(\" \"),s(\"li\",[_._v(\"接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，\")])]),_._v(\" \"),s(\"p\",[_._v(\"那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。\")]),_._v(\" \"),s(\"blockquote\",[s(\"p\",[_._v(\"为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？\")])]),_._v(\" \"),s(\"p\",[_._v(\"这是因为\"),s(\"strong\",[_._v(\"申请 MDL 锁的操作会形成一个队列\")]),_._v(\"，队列中\"),s(\"strong\",[_._v(\"写锁获取优先级高于读锁\")]),_._v(\"，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。\")]),_._v(\" \"),s(\"p\",[_._v(\"所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更\")]),_._v(\" \"),s(\"h2\",{attrs:{id:\"行锁\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#行锁\"}},[_._v(\"#\")]),_._v(\" 行锁\")]),_._v(\" \"),s(\"p\",[_._v(\"MySQL 的行锁是在引擎层由各个引擎自己实现的。但\"),s(\"strong\",[_._v(\"并不是所有的引擎都支持行锁\")]),_._v(\"，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。\"),s(\"strong\",[_._v(\"InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一\")]),_._v(\"。这里主要聊聊 InnoDB 的行锁，以及如何通过减少锁冲突来提升业务并发度。\")]),_._v(\" \"),s(\"p\",[s(\"strong\",[_._v(\"行锁就是针对数据表中行记录的锁。\")])]),_._v(\" \"),s(\"p\",[_._v(\"我先给你举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键：\")]),_._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230119175158395.png\",alt:\"image-20230119175158395\"}})]),_._v(\" \"),s(\"p\",[_._v(\"这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。\")]),_._v(\" \"),s(\"p\",[_._v(\"知道了这个答案，你一定知道了事务 A 持有的两个记录的行锁，\"),s(\"strong\",[_._v(\"都是在 commit 的时候才释放的。也就是说，在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。\"),s(\"strong\",[_._v(\"这个就是\")]),_._v(\"两阶段锁协议\")]),_._v(\"。\")]),_._v(\" \"),s(\"p\",[_._v(\"知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。\")]),_._v(\" \"),s(\"p\",[_._v(\"如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。我给你举个例子。\")]),_._v(\" \"),s(\"p\",[_._v(\"假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：\")]),_._v(\" \"),s(\"ol\",[s(\"li\",[_._v(\"从顾客 A 账户余额中扣除电影票价；\")]),_._v(\" \"),s(\"li\",[_._v(\"给影院 B 的账户余额增加这张电影票价；\")]),_._v(\" \"),s(\"li\",[_._v(\"记录一条交易日志。\")])]),_._v(\" \"),s(\"p\",[_._v(\"也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，\"),s(\"strong\",[_._v(\"你会怎样安排这三个语句在事务中的顺序呢 (之前只考虑到了原子性 但语句的顺序之前一直都没有咋考虑到)\")]),_._v(\"？\")]),_._v(\" \"),s(\"p\",[_._v(\"试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。\")]),_._v(\" \"),s(\"p\",[_._v(\"根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 \"),s(\"code\",[_._v(\"3、1、2\")]),_._v(\"这样的顺序，那么影院账户余额这一行的锁时间就最少。\"),s(\"strong\",[_._v(\"这就最大程度地减少了事务之间的锁等待，提升了并发度\")]),_._v(\"。\")]),_._v(\" \"),s(\"h2\",{attrs:{id:\"死锁和死锁检测\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁和死锁检测\"}},[_._v(\"#\")]),_._v(\" 死锁和死锁检测\")]),_._v(\" \"),s(\"ul\",[s(\"li\",[_._v(\"一种策略是，直接进入等待，直到\"),s(\"code\",[_._v(\"超时\")]),_._v(\"。这个超时时间可以通过参数 \"),s(\"strong\",[_._v(\"innodb_lock_wait_timeout\")]),_._v(\" 来设置。\")]),_._v(\" \"),s(\"li\",[_._v(\"另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 \"),s(\"strong\",[_._v(\"innodb_deadlock_detect\")]),_._v(\" 设置为 on，表示开启这个逻辑。\")])]),_._v(\" \"),s(\"p\",[_._v(\"在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，\"),s(\"strong\",[_._v(\"这个等待时间往往是无法接受的\")]),_._v(\"。\")]),_._v(\" \"),s(\"p\",[_._v(\"但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，\"),s(\"strong\",[_._v(\"超时时间设置太短的话，会出现很多误伤\")]),_._v(\"。\")]),_._v(\" \"),s(\"p\",[_._v(\"所以，\"),s(\"strong\",[_._v(\"正常情况下我们还是要采用第二种策略，即：主动死锁检测\")]),_._v(\"，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，\"),s(\"strong\",[_._v(\"但是它也是有额外负担的\")]),_._v(\"。\")])])}),[],!1,null,null,null);s.default=a.exports}}]);","extractedComments":[]}