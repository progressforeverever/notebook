{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[112],{439:function(o,v,_){\"use strict\";_.r(v);var n=_(4),r=Object(n.a)({},(function(){var o=this,v=o._self._c;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":o.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"redo-log-bin-log\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#redo-log-bin-log\"}},[o._v(\"#\")]),o._v(\" Redo Log && Bin Log\")]),o._v(\" \"),v(\"p\",[o._v(\"看MySQL 45讲的时候经常看见这两个，总是懵懵懂懂，来个总结先。具体的可以看\"),v(\"code\",[o._v(\"MySQL 02 日志系统：一条SQL更新语句是如何执行的？\")])]),o._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[o._v(\"Redo Log（重做日志）：\")])]),o._v(\" \"),v(\"ul\",[v(\"li\",[v(\"strong\",[o._v(\"作用：\")]),o._v(\" Redo Log是用于保证事务的持久性（Durability）的一种机制。当一个事务提交时，其所做的修改会首先写入重做日志，然后再写入磁盘上的数据库表。这样，在数据库发生故障时，可以通过重做日志来重新执行事务的修改，以保证数据库的一致性。\")]),o._v(\" \"),v(\"li\",[v(\"strong\",[o._v(\"特点：\")]),o._v(\" Redo Log是循环写的，它是一个固定大小的循环缓冲区，循环使用，确保记录了最近的事务修改。\")])])]),o._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[o._v(\"Binary Log（二进制日志）：\")])]),o._v(\" \"),v(\"ul\",[v(\"li\",[v(\"strong\",[o._v(\"作用：\")]),o._v(\" Binary Log用于数据库复制（replication）。它记录了对数据库的所有修改操作，包括插入、更新和删除等。通过将Binary Log从主数据库传输到从数据库，可以在从数据库上重放主数据库上的所有修改操作，实现数据复制。\")]),o._v(\" \"),v(\"li\",[v(\"strong\",[o._v(\"特点：\")]),o._v(\" Binary Log是线性写的，它记录了数据库中所有的修改操作，以便从服务器能够按照相同的顺序重演这些修改。它还可以用于恢复，但相较于Redo Log，它并不是用于崩溃恢复的主要工具。\")])])])]),o._v(\" \"),v(\"p\",[o._v(\"redo log 与 binlog 有以下\"),v(\"strong\",[o._v(\"三点不同\")]),o._v(\"：\")]),o._v(\" \"),v(\"ol\",[v(\"li\",[o._v(\"redo log 是 InnoDB 引擎特有的；\"),v(\"strong\",[o._v(\"binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\")])]),o._v(\" \"),v(\"li\",[v(\"strong\",[o._v(\"redo log 是物理日志\")]),o._v(\"，记录的是“在某个数据页上做了什么修改”；\"),v(\"strong\",[o._v(\"binlog 是逻辑日志\")]),o._v(\"，\"),v(\"strong\",[o._v(\"记录的是这个语句的原始逻辑\")]),o._v(\"，比如“给 ID=2 这一行的 c 字段加 1 ”。\")]),o._v(\" \"),v(\"li\",[o._v(\"redo log 是\"),v(\"strong\",[o._v(\"循环写的\")]),o._v(\"，空间固定会用完；binlog 是可以\"),v(\"strong\",[o._v(\"追加写入的\")]),o._v(\"。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\")])]),o._v(\" \"),v(\"p\",[o._v(\"有了对这两个日志的概念性理解，我们再来看执行器和 InnoDB 引擎在执行这个简单的 update 语句时的内部流程：\")]),o._v(\" \"),v(\"ol\",[v(\"li\",[o._v(\"执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在\"),v(\"strong\",[o._v(\"内存 cache\")]),o._v(\"中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。\")]),o._v(\" \"),v(\"li\",[o._v(\"执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。\")]),o._v(\" \"),v(\"li\",[o._v(\"引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 \"),v(\"strong\",[o._v(\"redo log 处于 prepare 状态\")]),o._v(\"。然后告知执行器执行完成了，随时可以提交事务。\")]),o._v(\" \"),v(\"li\",[v(\"strong\",[o._v(\"执行器生成这个操作的 binlog，并把 binlog 写入磁盘。\")])]),o._v(\" \"),v(\"li\",[o._v(\"执行器调用引擎的提交事务接口，\"),v(\"strong\",[o._v(\"引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。\")])])]),o._v(\" \"),v(\"p\",[o._v(\"下面给出这个 update 语句的执行流程图，图中浅色框表示是在 InnoDB 内部执行的，深色框表示是在执行器中执行的。\")]),o._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230117213746509.png\",alt:\"image-20230117213746509\"}})]),o._v(\" \"),v(\"p\",[v(\"strong\",[o._v('将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是\"两阶段提交\"。')])])])}),[],!1,null,null,null);v.default=r.exports}}]);","extractedComments":[]}