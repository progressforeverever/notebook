{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{409:function(s,v,_){\"use strict\";_.r(v);var t=_(4),a=Object(t.a)({},(function(){var s=this,v=s._self._c;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":s.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"es集群\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es集群\"}},[s._v(\"#\")]),s._v(\" es集群\")]),s._v(\" \"),v(\"p\",[s._v(\"单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点\")]),s._v(\" \"),v(\"li\",[s._v(\"单点故障问题：将分片数据在不同节点备份（replica ）\")])]),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"ES集群相关概念\")]),s._v(\":\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[s._v(\"集群（cluster）：一组拥有共同的 cluster name 的 节点。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"font\",{attrs:{color:\"red\"}},[s._v(\"节点（node)\")]),s._v(\"   ：集群中的一个 Elasticearch 实例\")],1)]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"font\",{attrs:{color:\"red\"}},[s._v(\"分片（shard）\")]),s._v(\"：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中\")],1),s._v(\" \"),v(\"p\",[s._v(\"解决问题：数据量太大，单点存储量有限的问题。\")]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es21.png\"}}),s._v(\" \"),v(\"blockquote\",[v(\"p\",[s._v(\"此处，我们把数据分成3片：shard0、shard1、shard2\")])])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"主分片（Primary shard）\")]),s._v(\"：相对于副本分片的定义。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"副本分片（Replica shard）每个主分片可以有一个或者多个副本\")]),s._v(\"，数据和主分片一样。\")]),s._v(\" \"),v(\"p\",[s._v(\"​\")])])]),s._v(\" \"),v(\"p\",[s._v(\"数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！\")]),s._v(\" \"),v(\"p\",[s._v(\"为了在高可用和成本间寻求平衡，我们可以这样做：\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[v(\"strong\",[s._v(\"首先对数据分片，存储到不同节点\")])]),s._v(\" \"),v(\"li\",[s._v(\"然后对每个分片进行备份，放到对方节点，完成互相备份\")])]),s._v(\" \"),v(\"p\",[s._v(\"这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：\")]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es22.png\"}}),s._v(\" \"),v(\"p\",[s._v(\"现在，每个分片都有1个备份，存储在3个节点：\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"node0：保存了分片0和1\")]),s._v(\" \"),v(\"li\",[s._v(\"node1：保存了分片0和2\")]),s._v(\" \"),v(\"li\",[s._v(\"node2：保存了分片1和2\")])]),s._v(\" \"),v(\"h2\",{attrs:{id:\"集群职责划分\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集群职责划分\"}},[s._v(\"#\")]),s._v(\" 集群职责划分\")]),s._v(\" \"),v(\"p\",[s._v(\"elasticsearch中集群节点有不同的职责划分：\")]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es23.png\"}}),s._v(\" \"),v(\"p\",[s._v(\"默认情况下，集群中的任何一个节点都同时具备上述四种角色。\")]),s._v(\" \"),v(\"p\",[s._v(\"但是真实的集群一定要将集群职责分离：\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"master节点：对CPU要求高，但是内存要求低\")]),s._v(\" \"),v(\"li\",[s._v(\"data节点：对CPU和内存要求都高\")]),s._v(\" \"),v(\"li\",[s._v(\"coordinating节点：对网络带宽、CPU要求高\")])]),s._v(\" \"),v(\"p\",[s._v(\"职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。\")]),s._v(\" \"),v(\"p\",[s._v(\"一个典型的es集群职责划分如图：\")]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es20.png\"}}),s._v(\" \"),v(\"p\",[s._v(\"master eligible节点的作用是什么？\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"参与集群选主\")]),s._v(\" \"),v(\"li\",[s._v(\"主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求\")])]),s._v(\" \"),v(\"p\",[s._v(\"data节点的作用是什么？\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"数据的CRUD\")])]),s._v(\" \"),v(\"p\",[s._v(\"coordinator节点的作用是什么？\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"路由请求到其它节点\")]),s._v(\" \"),v(\"li\",[s._v(\"合并查询到的结果，返回给用户\")])]),s._v(\" \"),v(\"h2\",{attrs:{id:\"脑裂问题\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#脑裂问题\"}},[s._v(\"#\")]),s._v(\" 脑裂问题\")]),s._v(\" \"),v(\"p\",[s._v(\"脑裂是因为集群中的节点失联导致的。\")]),s._v(\" \"),v(\"p\",[s._v(\"例如一个集群中，主节点与其它节点失联：\")]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es24.png\"}}),s._v(\" \"),v(\"p\",[s._v(\"此时，node2和node3认为node1宕机，就会重新选主：\")]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es25.png\"}}),s._v(\" \"),v(\"p\",[s._v(\"当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。\")]),s._v(\" \"),v(\"p\",[s._v(\"当网络恢复后，因\"),v(\"strong\",[s._v(\"为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：\")])]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es26.png\"}}),s._v(\" \"),v(\"p\",[v(\"strong\",[s._v(\"eligible   首先得是候选节点\")])]),s._v(\" \"),v(\"p\",[s._v(\"解决脑裂的方案是，\"),v(\"strong\",[s._v(\"要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数\")]),s._v(\"。\"),v(\"strong\",[s._v(\"对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题\")])]),s._v(\" \"),v(\"p\",[s._v(\"例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。\")]),s._v(\" \"),v(\"h2\",{attrs:{id:\"集群分布式存储\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集群分布式存储\"}},[s._v(\"#\")]),s._v(\" 集群分布式存储\")]),s._v(\" \"),v(\"p\",[s._v(\"当你插入文档时，Elasticsearch会根据文档ID使用哈希函数来决定将文档存储在哪个分片中。这个过程确保了数据在各个分片之间的均匀分布，从而实现数据的负载均衡。\")]),s._v(\" \"),v(\"p\",[s._v(\"具体的插入流程如下：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"选择主分片：\")]),s._v(\" Elasticsearch会根据**文档ID的哈希值来选择主分片。**每个文档ID会映射到一个特定的主分片，确保相同ID的文档始终存储在相同的主分片中。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"选择副本分片：\")]),s._v(\" 如果索引的副本数量大于1，那么Elasticsearch会自动选择其他数据节点上的副本分片来存储相同的文档。这增加了数据的冗余性和可用性。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"插入文档：\")]),s._v(\" 文档被插入到所选的主分片和副本分片中。数据存储在每个分片的本地存储上。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"同步副本：\")]),s._v(\" 如果存在副本，主分片会将插入的文档同步到对应的副本分片。这确保了数据的冗余和高可用性。\")])])]),s._v(\" \"),v(\"p\",[s._v(\"通过这种方式，Elasticsearch实现了文档的分布式存储，每个分片都存储了部分文档数据。当进行查询时，Elasticsearch会协调各个分片上的查询操作，并将结果进行汇总。整个过程是透明的，\"),v(\"strong\",[s._v(\"用户只需关注数据的插入和查询，而不需要关心数据具体存储在哪个分片上。这种分片和副本的机制使得Elasticsearch具有高可用性和扩展性。\")])]),s._v(\" \"),v(\"p\",[s._v(\"在默认情况下，Elasticsearch会根据文档的ID自动决定将文档插入到哪个分片中，以实现数据的均匀分布。然而，如果您确实有特定的需求，\"),v(\"strong\",[s._v(\"想要将文档插入到特定的分片中，您可以通过使用自定义的路由值来实现。\")])]),s._v(\" \"),v(\"p\",[s._v(\"路由值是一个自定义的字符串，您可以将其与文档一起插入，并在插入请求中指定使用该路由值。这样，Elasticsearch会使用该路由值来确定将文档存储在哪个分片中，而不是使用默认的哈希算法。\")]),s._v(\" \"),v(\"p\",[s._v(\"下面是一个示例操作：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"strong\",[s._v(\"插入文档时指定路由值：\")])])]),s._v(\" \"),v(\"div\",{staticClass:\"language-json line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-json\"}},[v(\"code\",[s._v(\"POST /my-index/_doc/\"),v(\"span\",{pre:!0,attrs:{class:\"token number\"}},[s._v(\"1\")]),s._v(\"?routing=my-custom-routing-value\\n\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"{\")]),s._v(\"\\n  \"),v(\"span\",{pre:!0,attrs:{class:\"token property\"}},[s._v('\"title\"')]),v(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\":\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v('\"Sample Document\"')]),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"\\n  \"),v(\"span\",{pre:!0,attrs:{class:\"token property\"}},[s._v('\"content\"')]),v(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\":\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v('\"This is the content of the document.\"')]),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\",\")]),s._v(\"\\n  \"),v(\"span\",{pre:!0,attrs:{class:\"token property\"}},[s._v('\"date\"')]),v(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[s._v(\":\")]),s._v(\" \"),v(\"span\",{pre:!0,attrs:{class:\"token string\"}},[s._v('\"2023-08-15\"')]),s._v(\"\\n\"),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\"}\")]),s._v(\"\\n\")])]),s._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[s._v(\"2\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[s._v(\"3\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[s._v(\"4\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[s._v(\"5\")]),v(\"br\"),v(\"span\",{staticClass:\"line-number\"},[s._v(\"6\")]),v(\"br\")])]),v(\"p\",[s._v(\"在上述示例中，使用了\"),v(\"code\",[s._v(\"routing\")]),s._v(\"参数来指定路由值为\"),v(\"code\",[s._v(\"my-custom-routing-value\")]),s._v(\"。Elasticsearch将根据该路由值来确定将文档存储在哪个分片中。\")]),s._v(\" \"),v(\"p\",[s._v(\"需要注意的是，使用自定义路由值可能会导致数据在分片之间不均匀分布，从而影响性能和负载均衡。在大多数情况下，Elasticsearch的自动分片机制已经足够满足需求，不需要显式指定插入分片。只有在特殊需求下，才建议使用自定义路由值。\")]),s._v(\" \"),v(\"h2\",{attrs:{id:\"集群分布式查询\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集群分布式查询\"}},[s._v(\"#\")]),s._v(\" 集群分布式查询\")]),s._v(\" \"),v(\"p\",[s._v(\"elasticsearch的查询分成两个阶段：\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[v(\"p\",[s._v(\"scatter phase：分散阶段，coordinating node\"),v(\"strong\",[s._v(\"会把请求分发到每一个分片\")])])]),s._v(\" \"),v(\"li\",[v(\"p\",[s._v(\"gather phase：\"),v(\"strong\",[s._v(\"聚集阶段\")]),s._v(\"，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户\")])])]),s._v(\" \"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/es27.png\"}}),s._v(\" \"),v(\"p\",[s._v(\"在Elasticsearch集群下进行查询涉及多个分片和节点的协同工作。整个查询流程可以概括为以下几个步骤：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"解析查询请求：\")]),s._v(\" 当您发送一个查询请求到Elasticsearch集群时，集群中的任意一个节点都可以接收该请求。该节点被称为协调节点（Coordinator Node）。协调节点负责解析查询请求，了解要查询的索引、字段、查询条件等信息。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"分发查询：\")]),s._v(\" 协调节点根据查询请求的信息，决定将查询分发给哪些包含相关数据的分片。例如，如果查询涉及到一个特定索引和字段，协调节点会查找包含该索引和字段的主分片以及其副本。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"查询分片：\")]),s._v(\" 协调节点向包含相关数据的分片发送查询请求。每个分片在本地执行查询操作，返回与查询匹配的文档及其相关信息。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"汇总结果：\")]),s._v(\" 协调节点收集来自各个分片的查询结果，并将这些结果进行合并和排序，以生成最终的查询结果列表。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"返回结果：\")]),s._v(\" 协调节点将最终的查询结果返回给客户端，供用户查看和处理。\")])])]),s._v(\" \"),v(\"p\",[s._v(\"在这个查询流程中，协调节点起着重要的作用，它协调各个分片的查询操作，并将结果汇总返回。每个分片负责处理自己存储的文档数据，从而实现并行处理和分布式查询的能力。\")]),s._v(\" \"),v(\"p\",[s._v(\"需要注意的是，Elasticsearch的查询引擎具有高度的优化和并行执行能力，可以同时查询多个分片，从而提高查询性能。同时，查询会自动利用分片和副本来分担负载和保证高可用性。\")]),s._v(\" \"),v(\"h2\",{attrs:{id:\"故障转移\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#故障转移\"}},[s._v(\"#\")]),s._v(\" 故障转移\")]),s._v(\" \"),v(\"p\",[s._v(\"Elasticsearch集群的故障转移是指在集群中的某个节点发生故障时，集群可以自动进行恢复和重新分配，以确保数据的可用性和集群的稳定运行。故障转移是实现高可用性的关键机制之一。\")]),s._v(\" \"),v(\"p\",[s._v(\"以下是Elasticsearch集群故障转移的基本过程：\")]),s._v(\" \"),v(\"h3\",{attrs:{id:\"节点故障检测\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#节点故障检测\"}},[s._v(\"#\")]),s._v(\" 节点故障检测\")]),s._v(\" \"),v(\"p\",[s._v(\"在Elasticsearch集群中，节点故障检测是保障高可用性的关键步骤之一。当集群中的某个节点出现故障或不可用时，其他节点需要及时感知并采取相应措施。节点故障检测通常涉及以下几个方面：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"心跳检测：\")]),s._v(\" 每个节点会定期向集群中的其他节点发送心跳信号。心跳信号是一种小而快速的通信，用于确认节点是否存活。如果一个节点在一段时间内没有响应心跳信号，其他节点会将其标记为潜在的故障节点。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"Gossip协议：\")]),s._v(\" **Elasticsearch使用Gossip协议来在集群中传播节点状态信息。**当一个节点检测到其他节点不可用时，它会将这个信息通过Gossip协议广播给其他节点。这种方式使得节点之间能够及时通知彼此有关故障的信息。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"超时机制：\")]),s._v(\" 节点在等待其他节点响应时会设置一个超时阈值。如果在超时时间内没有收到心跳响应，节点会认为目标节点不可用，将其标记为故障节点。**Elasticsearch的超时机制默认情况下是30秒。**也就是说，当一个节点向另一个节点发送心跳信号后，如果在30秒内没有收到响应，就会将目标节点标记为不可用或潜在的故障节点。这个超时时间可以通过集群配置进行调整，以适应不同的网络环境和延迟情况。\")]),s._v(\" \"),v(\"p\",[s._v(\"在Elasticsearch的集群配置文件（\"),v(\"code\",[s._v(\"elasticsearch.yml\")]),s._v(\"）中，您可以通过修改以下配置项来更改超时时间：\")]),s._v(\" \"),v(\"div\",{staticClass:\"language-yaml line-numbers-mode\"},[v(\"pre\",{pre:!0,attrs:{class:\"language-yaml\"}},[v(\"code\",[v(\"span\",{pre:!0,attrs:{class:\"token key atrule\"}},[s._v(\"discovery.zen.fd.ping_timeout\")]),v(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[s._v(\":\")]),s._v(\" 30s\\n\")])]),s._v(\" \"),v(\"div\",{staticClass:\"line-numbers-wrapper\"},[v(\"span\",{staticClass:\"line-number\"},[s._v(\"1\")]),v(\"br\")])]),v(\"p\",[s._v(\"在上面的配置中，\"),v(\"code\",[s._v(\"discovery.zen.fd.ping_timeout\")]),s._v(\"配置项表示心跳的超时时间，单位为秒。您可以将其修改为适合您集群环境的值。值得注意的是，将超时时间设置得太短可能会导致误报故障，而将超时时间设置得太长可能会延迟故障的检测和响应。因此，需要根据实际情况进行调整。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"故障检测阶段：\")]),s._v(\" 一旦节点被标记为潜在的故障节点，Elasticsearch会进行故障检测的阶段。在这个阶段，节点会进一步验证目标节点的状态，以避免误报故障。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"自动主节点选举：\")]),s._v(\" 如果主节点发生故障，集群会自动进行主节点选举，选择一个新的主节点来继续管理集群。这确保了主节点的可用性，从而保障集群的正常运行。\")])])]),s._v(\" \"),v(\"p\",[s._v(\"总体来说，节点故障检测机制使得Elasticsearch集群能够在节点故障时及时感知并做出相应的调整，保障了数据的高可用性和集群的稳定性。这种机制允许集群中的其他节点在出现故障时继续提供服务，确保系统的连续性。\")]),s._v(\" \"),v(\"h3\",{attrs:{id:\"主节点选举\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#主节点选举\"}},[s._v(\"#\")]),s._v(\" 主节点选举\")]),s._v(\" \"),v(\"p\",[s._v(\"在Elasticsearch集群中，每个主分片和副本分片都有一个主节点（primary shard）。主节点负责管理分片的写入操作和分片的分配。当主节点发生故障或不可用时，集群需要通过主节点选举来选择一个新的主节点，以确保数据的正常写入和分配。\")]),s._v(\" \"),v(\"p\",[s._v(\"主节点选举的过程如下：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"主节点失效检测：\")]),s._v(\" 当集群中的主节点发生故障或不可用时，其他节点会注意到主节点的失效，并将其标记为不可用。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"选举触发：\")]),s._v(\" 一旦主节点被标记为不可用，集群中的其他节点会自动触发主节点选举过程。这是一个自动化的过程，无需人工干预。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"选举条件：\")]),s._v(\" 为了选择新的主节点，集群中的候选节点会通过协商达成共识。通常情况下，候选节点需要满足以下条件：\")]),s._v(\" \"),v(\"ul\",[v(\"li\",[s._v(\"节点必须存活并参与集群中的通信。\")]),s._v(\" \"),v(\"li\",[s._v(\"节点必须能够访问足够数量的副本分片。\")])])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"选举结果：\")]),s._v(\" 一旦候选节点达成共识，集群会选出一个新的主节点。新的主节点会负责管理主分片的写入操作和分片的分配。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"重新分配：\")]),s._v(\" 新的主节点选举完成后，集群会根据新的主节点重新分配数据分片。这确保了分片的均衡分布和高可用性。\")])])]),s._v(\" \"),v(\"p\",[s._v(\"需要注意的是，主节点选举是集群内部自动处理的过程，不需要手动干预。Elasticsearch集群的主节点选举机制确保了主节点的高可用性，从而保障了数据写入和分配的正常运行。\")]),s._v(\" \"),v(\"p\",[s._v(\"Elasticsearch在进行主节点选举时使用的是基于Paxos算法的选举策略，具体来说是**Multi-Paxos。Paxos是一种分布式一致性算法，**用于解决分布式系统中的数据一致性问题。在Elasticsearch中，Multi-Paxos算法用于保证主节点选举的正确性和可靠性。\")]),s._v(\" \"),v(\"p\",[s._v(\"主节点选举的过程基于Multi-Paxos算法，涉及以下几个角色和阶段：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"候选节点（Candidate Nodes）：\")]),s._v(\" 候选节点是参与主节点选举的各个节点，包括原主节点失效后的候选节点。候选节点会根据Paxos算法达成共识，选择一个新的主节点。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"提议（Proposal）：\")]),s._v(\" 候选节点可以提出一个提议，即宣布自己成为新的主节点。提议包括候选节点的标识信息和编号。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"阶段一：准备（Prepare）阶段：\")]),s._v(\" 在这个阶段，候选节点会向其他节点发送准备请求，请求其他节点返回他们的最高编号的提议。每个节点将自己的最高提议编号回复给候选节点。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"阶段二：承诺（Promise）阶段：\")]),s._v(\" 在这个阶段，候选节点收集其他节点返回的提议编号。如果候选节点收到了超过半数的节点的承诺，并且没有收到更高编号的提议，那么它就会进入下一个阶段。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"阶段三：接受（Accept）阶段：\")]),s._v(\" 在这个阶段，候选节点向其他节点发送接受请求，告知它们自己成为新的主节点。如果候选节点收到了超过半数的节点的接受，它就会成为新的主节点。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"选举结果：\")]),s._v(\" **当一个候选节点成功地进行了接受并收到了超过半数的接受响应后，**它就成为了新的主节点。其他节点会更新自己的状态，以适应新的主节点。\")])])]),s._v(\" \"),v(\"p\",[s._v(\"总之，Elasticsearch通过基于Multi-Paxos算法的选举策略，确保在主节点发生故障时能够自动选出新的主节点，以保障集群的高可用性和稳定性。\")]),s._v(\" \"),v(\"p\",[s._v(\"前置条件：\")]),s._v(\" \"),v(\"p\",[s._v(\"1）\"),v(\"strong\",[s._v(\"只有是候选主节点\")]),s._v(\" (master：true)的节点才能成为主节点。\")]),s._v(\" \"),v(\"p\",[s._v(\"2）\"),v(\"strong\",[s._v(\"最小主节点数（min_master_nodes）的目的是防止脑裂。\")])]),s._v(\" \"),v(\"p\",[s._v(\"Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个RPC来发现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；\")]),s._v(\" \"),v(\"p\",[s._v(\"获取主节点的核心入口为findMaster，选择主节点成功返回对应Master，否则返回null。\")]),s._v(\" \"),v(\"p\",[s._v(\"选举流程大致描述如下：\")]),s._v(\" \"),v(\"p\",[s._v(\"第一步：确认候选主节点数达标，elasticsearch.yml设置的值discovery.zen.minimum_master_nodes。\")]),s._v(\" \"),v(\"p\",[s._v(\"第二步：对所有候选主节点根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。\")]),s._v(\" \"),v(\"p\",[s._v(\"第三步：如果对某个节点的投票数达到一定的值（候选主节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。\")]),s._v(\" \"),v(\"p\",[s._v(\"选举流程总结：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[s._v(\"Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；\")]),s._v(\" \"),v(\"li\",[s._v(\"对所有可以成为master的节点（node.master:true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。\")]),s._v(\" \"),v(\"li\",[s._v(\"如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。\")]),s._v(\" \"),v(\"li\",[s._v(\"master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http功能*。\")])]),s._v(\" \"),v(\"p\",[s._v(\"假如还有的话，待写。todo\")]),s._v(\" \"),v(\"h2\",{attrs:{id:\"es与mysql同步问题\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#es与mysql同步问题\"}},[s._v(\"#\")]),s._v(\" es与MySQL同步问题\")]),s._v(\" \"),v(\"p\",[s._v(\"将Elasticsearch与MySQL实现数据同步通常涉及两个不同的数据存储系统，一个是关系型数据库MySQL，另一个是全文搜索引擎Elasticsearch。数据同步的目标是将MySQL中的数据实时或定期地同步到Elasticsearch中，以便在Elasticsearch中进行更高效的全文搜索和分析操作。\")]),s._v(\" \"),v(\"p\",[s._v(\"以下是一种常见的方法来实现MySQL与Elasticsearch的数据同步：\")]),s._v(\" \"),v(\"ol\",[v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"使用Logstash：\")]),s._v(\" Logstash是Elasticsearch官方提供的开源数据收集和传输工具。它可以从多个数据源中收集数据，经过处理后发送到Elasticsearch。对于MySQL与Elasticsearch的数据同步，您可以使用\"),v(\"strong\",[s._v(\"Logstash的JDBC输入插件\")]),s._v(\"来连接MySQL数据库，并使用Elasticsearch输出插件将数据发送到Elasticsearch中。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"配置Logstash Pipeline：\")]),s._v(\" \"),v(\"strong\",[s._v(\"配置Logstash的Pipeline文件\")]),s._v(\"，指定MySQL数据库的连接信息、查询语句等。您可以定期执行同步操作，或者根据数据变化情况实时同步。通过配置适当的过滤器，您可以对MySQL中的数据进行预处理，例如转换数据格式、清洗数据等。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"Elasticsearch索引映射：\")]),s._v(\" 在Logstash的Pipeline中，您可以指定将MySQL中的数据如何映射到Elasticsearch索引中的字段。这涉及到定义索引的映射(mapping)，以便Elasticsearch正确解析和索引数据。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"定期同步或实时同步：\")]),s._v(\" 您可以设置Logstash的同步频率，例如每隔一段时间执行一次同步操作，或者使用实时数据变化触发同步。\")])]),s._v(\" \"),v(\"li\",[v(\"p\",[v(\"strong\",[s._v(\"监控和错误处理：\")]),s._v(\" 监控同步过程，确保同步操作的稳定性和可靠性。Logstash提供了日志和监控信息，帮助您进行错误处理和调优。\")])])]),s._v(\" \"),v(\"p\",[s._v(\"需要注意的是，虽然Logstash是常用的工具，但还有其他方法可以实现MySQL与Elasticsearch的数据同步，例如使用编程语言编写自定义同步脚本，或者使用第三方工具和库。具体的方法选择取决于您的需求、技术栈和项目情况。\")]),s._v(\" \"),v(\"p\",[s._v(\"同理   mongodb转es\")])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}