{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{423:function(t,s,a){\"use strict\";a.r(s);var n=a(4),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"mysql-06-事务到底是隔离的还是不隔离的\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#mysql-06-事务到底是隔离的还是不隔离的\"}},[t._v(\"#\")]),t._v(\" MySQL 06 | 事务到底是隔离的还是不隔离的？\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"这个感觉有点抽象了    就到时候还得回头看   先记着，然后再跳过去\")])]),t._v(\" \"),s(\"p\",[t._v(\"前面说了，如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，事务 T 看到的仍然跟在启动时看到的一样。但在\"),s(\"RouterLink\",{attrs:{to:\"/pages/8d05b4/\"}},[t._v(\"全局锁、表级锁和行锁\")]),t._v(\"中提到，一个事务要更新一行，如果刚好有另外一个事务拥有这一行的行锁，它又不能这么独身事外了，它会被锁住，进入等待状态。问题是，既然进入了等待状态，那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？\")],1),t._v(\" \"),s(\"p\",[t._v(\"举一个例子，下面是一个只有两行的表的初始化语句：\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[s(\"code\",[t._v(\"mysql\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"CREATE\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"TABLE\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token identifier\"}},[s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")]),t._v(\"t\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")])]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token identifier\"}},[s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")]),t._v(\"id\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")])]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"11\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"NOT\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[t._v(\"NULL\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token identifier\"}},[s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")]),t._v(\"k\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")])]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"int\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"11\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"DEFAULT\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token boolean\"}},[t._v(\"NULL\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"PRIMARY\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"KEY\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token identifier\"}},[s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")]),t._v(\"id\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"`\")])]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"ENGINE\")]),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"InnoDB\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"insert\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"into\")]),t._v(\" t\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),t._v(\"id\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),t._v(\" k\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"values\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\",\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"2\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\")\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"4\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"5\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"6\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"7\")]),s(\"br\")])]),s(\"p\",[t._v(\"事务 A、B、C 的流程如下：\")]),t._v(\" \"),s(\"center\",[s(\"img\",{staticStyle:{zoom:\"90%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120184944142.png\",alt:\"image-20230120184944142\"}})]),t._v(\" \"),s(\"p\",[t._v(\"这里，我们需要注意的是事务的启动时机。begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"第一种启动方式：一致性视图是在执行第一个快照读语句时创建的；\")]),t._v(\" \"),s(\"li\",[t._v(\"第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。\")])]),t._v(\" \"),s(\"p\",[t._v(\"还需注意的是，之后如果没有特别说明，都默认 autocommit=1，也就是即使没有手动 start transaction 开启事务，mysql 默认也会将用户的操作当做事务即时提交。\")]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"现在你知道 A、B 事务看到的值是什么吗\")]),t._v(\"。这一大节就把这个疑惑解开，更深一步地理解 MVCC。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"snapshot-在-mvcc-里是怎样工作的\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#snapshot-在-mvcc-里是怎样工作的\"}},[t._v(\"#\")]),t._v(\" snapshot 在 MVCC 里是怎样工作的？\")]),t._v(\" \"),s(\"p\",[t._v(\"在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，\"),s(\"strong\",[t._v(\"这个快照是基于整库的\")]),t._v(\"。\")]),t._v(\" \"),s(\"p\",[t._v(\"但真的要给全库拍快照又不太可行，一个数据库有 100G，怎么可能每个事务都先复制 100G 数据出来。实际上，DB 并不需要真的拷贝这 100G 数据。我们看一下这个 snapshot 是怎么实现的。\")]),t._v(\" \"),s(\"p\",[t._v(\"InnoDB 里面每个事务有一个唯一的事务 ID，叫作 \"),s(\"mark\",[t._v(\"transaction id\")]),t._v(\"。它是在事务开始的时候向 InnoDB 的事务系统申请的，是\"),s(\"strong\",[t._v(\"按申请顺序严格递增的\")]),t._v(\"。而\"),s(\"strong\",[t._v(\"每行数据也都是有多个版本的\")]),t._v(\"。每次事务更新数据的时候，\"),s(\"strong\",[t._v(\"都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID\")]),t._v(\"，记为 \"),s(\"mark\",[t._v(\"row trx_id\")]),t._v(\"。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。\")])]),t._v(\" \"),s(\"p\",[t._v(\"下图就是一个记录被多个事务连续更新后的状态：\")]),t._v(\" \"),s(\"center\",[s(\"img\",{staticStyle:{zoom:\"90%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120190328050.png\",alt:\"image-20230120190328050\"}})]),t._v(\" \"),s(\"p\",[t._v(\"图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。\")]),t._v(\" \"),s(\"p\",[t._v(\"其实，图中的三个绿色虚线箭头就是 undo log（回滚日志），而且 \"),s(\"strong\",[t._v(\"旧版本 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的\")]),t._v(\"。比如在需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。\")]),t._v(\" \"),s(\"p\",[t._v(\"明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。\")]),t._v(\" \"),s(\"p\",[t._v(\"按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。因此，一个事务只需要在启动后只承认那些位于自己启动之前的数据版本和自己更新的数据就好了。\")]),t._v(\" \"),s(\"p\",[t._v(\"在实现上，\"),s(\"strong\",[t._v(\"InnoDB 为每个事务构造了一个\"),s(\"mark\",[t._v(\"视图数组\")]),t._v(\"，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID\")]),t._v(\"。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为\"),s(\"mark\",[t._v(\"低水位\")]),t._v(\"，当前系统里面已经创建过的事务 ID 的最大值加 1 记为\"),s(\"mark\",[t._v(\"高水位\")]),t._v(\"。这个视图数组和高水位，就组成了当前事务的\"),s(\"mark\",[t._v(\"一致性视图\")]),t._v(\"（\"),s(\"strong\",[t._v(\"read-view\")]),t._v(\"）。而\"),s(\"strong\",[t._v(\"数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的\")]),t._v(\"。\")]),t._v(\" \"),s(\"p\",[t._v(\"这个视图数组把所有的 row trx_id 分成了几种不同的情况：\")]),t._v(\" \"),s(\"center\",[s(\"img\",{attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120191357827.png\",alt:\"image-20230120191357827\"}})]),t._v(\" \"),s(\"p\",[t._v(\"这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：\")]),t._v(\" \"),s(\"ol\",[s(\"li\",[t._v(\"如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，\"),s(\"strong\",[t._v(\"这个数据是可见的\")]),t._v(\"；\")]),t._v(\" \"),s(\"li\",[t._v(\"如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；\")]),t._v(\" \"),s(\"li\",[t._v(\"如果落在\"),s(\"strong\",[t._v(\"黄色部分\")]),t._v(\"，那就包括两种情况：\\n\"),s(\"ul\",[s(\"li\",[t._v(\"若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见\")]),t._v(\" \"),s(\"li\",[t._v(\"若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见\")])])])]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"易混：\"),s(\"strong\",[t._v(\"落在黄色区域意味着是事务 ID 在低水位和高水位这个范围里面，而真正是是否可见，看黄色区域是否有这个值\")]),t._v(\"。如果黄色区域没有这个事务 ID，则可见，如果有，则不可见。在这个范围里面并不意味这这个范围里有这个值，比如 [1,2,3,5]，4 在这个数组 1-5 的范围里，却没在这个数组里面。\")])]),t._v(\" \"),s(\"p\",[t._v(\"比如，对于图 2 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。\")]),t._v(\" \"),s(\"p\",[t._v(\"有了这个可见性规则，系统里面随后发生的更新就与这个事务看到的内容无关了，所以这个事务的 snapshot 就是“静态”的了。所以你现在知道了，\"),s(\"font\",{attrs:{color:\"blue\"}},[t._v(\"InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力\")]),t._v(\"。\")],1),t._v(\" \"),s(\"p\",[t._v(\"现在借助于这个知识，我们对之前的例子进行分析。我们不妨假设：\")]),t._v(\" \"),s(\"ol\",[s(\"li\",[t._v(\"事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；\")]),t._v(\" \"),s(\"li\",[t._v(\"事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；\")]),t._v(\" \"),s(\"li\",[t._v(\"三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。\")])]),t._v(\" \"),s(\"p\",[t._v(\"这样，事务 A 的视图数组就是[99,100], 事务 B 的视图数组是[99,100,101], 事务 C 的视图数组是[99,100,101,102]。为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：\")]),t._v(\" \"),s(\"img\",{staticStyle:{zoom:\"90%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120193049568.png\",alt:\"image-20230120193049568\"}}),t._v(\" \"),s(\"p\",[t._v(\"从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。好，现在事务 A 要来读数据了，它的视图数组是[99,100]。当然了，读数据都是从当前版本读起的。\")]),t._v(\" \"),s(\"p\",[t._v(\"所以，事务 A 查询语句的读数据流程是这样的：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；\")]),t._v(\" \"),s(\"li\",[t._v(\"接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；\")]),t._v(\" \"),s(\"li\",[t._v(\"再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。\")])]),t._v(\" \"),s(\"p\",[t._v(\"这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为\"),s(\"strong\",[t._v(\"一致性读\")]),t._v(\"。\")]),t._v(\" \"),s(\"p\",[t._v(\"这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。所以，用更直观的话说：\"),s(\"strong\",[t._v(\"一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况\")]),t._v(\"：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[s(\"font\",{attrs:{color:\"green\"}},[t._v(\"版本未提交，不可见\")]),t._v(\"；\")],1),t._v(\" \"),s(\"li\",[s(\"font\",{attrs:{color:\"green\"}},[t._v(\"版本已提交，但是是在视图创建后提交的，不可见\")]),t._v(\"；\")],1),t._v(\" \"),s(\"li\",[s(\"font\",{attrs:{color:\"green\"}},[t._v(\"版本已提交，而且是在视图创建前提交的，可见\")]),t._v(\"。\")],1)]),t._v(\" \"),s(\"p\",[t._v(\"现在，我们用这个规则来判断示例中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"(1,3) 还没提交，属于情况 1，不可见；\")]),t._v(\" \"),s(\"li\",[t._v(\"(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；\")]),t._v(\" \"),s(\"li\",[t._v(\"(1,1) 是在视图数组创建之前提交的，可见。\")])]),t._v(\" \"),s(\"p\",[t._v(\"你看，\"),s(\"strong\",[t._v(\"去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了\")]),t._v(\"。所以，后面我们就都用这个规则来分析。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"更新逻辑\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#更新逻辑\"}},[t._v(\"#\")]),t._v(\" 更新逻辑\")]),t._v(\" \"),s(\"p\",[t._v(\"更细心的话，可以提出这样一个疑问：\"),s(\"strong\",[t._v(\"事务 B 的 update 语句，如果按照一致性读，好像结果不对哦\")]),t._v(\"？你看图 5 中，事务 B 的视图数组是先生成的，之后事务 C 才提交，不是应该看不见 (1,2) 吗，怎么能算出 (1,3) 来？\")]),t._v(\" \"),s(\"center\",[s(\"img\",{staticStyle:{zoom:\"80%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120193831898.png\",alt:\"image-20230120193831898\"}})]),t._v(\" \"),s(\"p\",[t._v(\"是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。但是，\"),s(\"strong\",[t._v(\"当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了\")]),t._v(\"。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。\")]),t._v(\" \"),s(\"p\",[t._v(\"所以，这里就用到了这样一条规则：\"),s(\"font\",{attrs:{color:\"blue\"}},[t._v(\"更新数据都是先读后写的，而这个读，只能读当前的值\")]),t._v(\"，称为“\"),s(\"mark\",[t._v(\"当前读\")]),t._v(\"”（\"),s(\"strong\",[t._v(\"current read\")]),t._v(\"）。\")],1),t._v(\" \"),s(\"p\",[t._v(\"因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。\")]),t._v(\" \"),s(\"p\",[t._v(\"这里我们提到了一个概念，叫作当前读。其实，\"),s(\"strong\",[t._v(\"除了 update 语句外，select 语句如果加锁，也是当前读\")]),t._v(\"。所以，如果把事务 A 的查询语句 select * from t where id=1 修改一下，加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）：\")]),t._v(\" \"),s(\"div\",{staticClass:\"language-sql line-numbers-mode\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-sql\"}},[s(\"code\",[t._v(\"mysql\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"select\")]),t._v(\" k \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"from\")]),t._v(\" t \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"where\")]),t._v(\" id\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"lock\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"in\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"share\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"mode\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\nmysql\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\">\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"select\")]),t._v(\" k \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"from\")]),t._v(\" t \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"where\")]),t._v(\" id\"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[t._v(\"=\")]),s(\"span\",{pre:!0,attrs:{class:\"token number\"}},[t._v(\"1\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"for\")]),t._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[t._v(\"update\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[t._v(\";\")]),t._v(\"\\n\")])]),t._v(\" \"),s(\"div\",{staticClass:\"line-numbers-wrapper\"},[s(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),s(\"br\"),s(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),s(\"br\")])]),s(\"p\",[t._v(\"再往前一步，假设事务 C 不是马上提交的，而是变成了下面的事务 C’，会怎么样呢？\")]),t._v(\" \"),s(\"center\",[s(\"img\",{staticStyle:{zoom:\"90%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120194318603.png\",alt:\"image-20230120194318603\"}})]),t._v(\" \"),s(\"p\",[t._v(\"事务 C’的不同是，更新后并没有马上提交，在它提交前，事务 B 的更新语句先发起了。前面说过了，虽然事务 C’还没提交，但是 (1,2) 这个版本也已经生成了，并且是当前的最新版本。那么，事务 B 的更新语句会怎么处理呢？\")]),t._v(\" \"),s(\"p\",[t._v(\"这时候，我们在上一篇文章中提到的“两阶段锁协议”就要上场了。事务 C’ 没提交，也就是说 (1,2) 这个版本上的写锁还没释放。而事务 B 是当前读，必须要读最新版本，而且必须加锁，因此就被锁住了，必须等到事务 C’ 释放这个锁，才能继续它的当前读。\")]),t._v(\" \"),s(\"center\",[s(\"img\",{staticStyle:{zoom:\"80%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120195038403.png\",alt:\"image-20230120195038403\"}})]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"到这里，我们把一致性读、当前读和行锁就串起来了\")]),t._v(\"。\")]),t._v(\" \"),s(\"p\",[t._v(\"现在，我们再回到文章开头的问题：事务的可重复读的能力是怎么实现的？\"),s(\"font\",{attrs:{color:\"blue\"}},[t._v(\"可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待\")]),t._v(\"。\")],1),t._v(\" \"),s(\"p\",[t._v(\"而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；\")]),t._v(\" \"),s(\"li\",[t._v(\"在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。\")])]),t._v(\" \"),s(\"p\",[t._v(\"那么，我们再看一下，\"),s(\"strong\",[t._v(\"在读提交隔离级别下，事务 A 和事务 B 的查询语句查到的 k，分别应该是多少呢\")]),t._v(\"？\")]),t._v(\" \"),s(\"blockquote\",[s(\"p\",[t._v(\"这里需要说明一下，“start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。\")])]),t._v(\" \"),s(\"p\",[t._v(\"下面是读提交时的状态图，可以看到这两个查询语句的创建视图数组的时机发生了变化，就是图中的 read view 框。（注意：这里，我们用的还是事务 C 的逻辑直接提交，而不是事务 C’）\")]),t._v(\" \"),s(\"center\",[s(\"img\",{staticStyle:{zoom:\"80%\"},attrs:{src:\"https://notebook-img-1304596351.cos.ap-beijing.myqcloud.com/img/image-20230120195418637.png\",alt:\"image-20230120195418637\"}})]),t._v(\" \"),s(\"p\",[t._v(\"这时，事务 A 的查询语句的视图数组是在执行这个语句的时候创建的，时序上 (1,2)、(1,3) 的生成时间都在创建这个视图数组的时刻之前。但是，在这个时刻：\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"(1,3) 还没提交，属于情况 1，不可见；\")]),t._v(\" \"),s(\"li\",[t._v(\"(1,2) 提交了，属于情况 3，可见。\")])]),t._v(\" \"),s(\"p\",[t._v(\"所以，这时候事务 A 查询语句返回的是 k=2。显然地，事务 B 查询结果 k=3。\")]),t._v(\" \"),s(\"h3\",{attrs:{id:\"summary\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#summary\"}},[t._v(\"#\")]),t._v(\" Summary\")]),t._v(\" \"),s(\"p\",[t._v(\"InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。\")]),t._v(\" \"),s(\"ul\",[s(\"li\",[t._v(\"对于可重复读，查询只承认在事务启动前就已经提交完成的数据；\")]),t._v(\" \"),s(\"li\",[t._v(\"对于读提交，查询只承认在语句启动前就已经提交完成的数据；\")])]),t._v(\" \"),s(\"p\",[t._v(\"而当前读，总是读取已经提交完成的最新版本。\")]),t._v(\" \"),s(\"p\",[t._v(\"你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。\")]),t._v(\" \"),s(\"p\",[t._v(\"当然，MySQL 8.0 已经可以把表结构放在 InnoDB 字典里了，也许以后会支持表结构的可重复读。\")])],1)}),[],!1,null,null,null);s.default=r.exports}}]);","extractedComments":[]}