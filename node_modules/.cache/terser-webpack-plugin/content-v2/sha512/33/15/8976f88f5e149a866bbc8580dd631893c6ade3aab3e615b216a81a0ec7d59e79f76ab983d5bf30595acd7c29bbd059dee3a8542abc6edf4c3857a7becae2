{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{455:function(t,v,_){\"use strict\";_.r(v);var s=_(4),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[v(\"h1\",{attrs:{id:\"进程与线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程与线程\"}},[t._v(\"#\")]),t._v(\" 进程与线程\")]),t._v(\" \"),v(\"h2\",{attrs:{id:\"基本概念\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本概念\"}},[t._v(\"#\")]),t._v(\" 基本概念\")]),t._v(\" \"),v(\"p\",[t._v(\"程序：是静态的，就是个存放在磁盘里的 可执行文件，如：QQ.exe。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"进程：是动态的，是程序的一次执行过程\")]),t._v(\"， 如：可同时启动多次QQ程序\")]),t._v(\" \"),v(\"p\",[t._v(\"同一个程序\"),v(\"strong\",[t._v(\"多次执行会对应多个进程\")])]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025095832261.png\",alt:\"image-20231025095832261\"}})]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程的组成pcb\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的组成pcb\"}},[t._v(\"#\")]),t._v(\" 进程的组成PCB\")]),t._v(\" \"),v(\"p\",[t._v(\"操作系统如何区分进程？\")]),t._v(\" \"),v(\"p\",[t._v(\"当进程被创建时，操作系统会为该进程 分配一个唯一的、\"),v(\"strong\",[t._v(\"不重复的“身份证 号”——PID（ProcessID，进程ID）\")])]),t._v(\" \"),v(\"p\",[t._v(\"操作系统要记录PID、进程所属用户ID（UID）\")]),t._v(\" \"),v(\"p\",[t._v(\"还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）\")]),t._v(\" \"),v(\"p\",[t._v(\"还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）\")]),t._v(\" \"),v(\"p\",[t._v(\"这些信息都被保存在一个\"),v(\"strong\",[t._v(\"数据结构PCB（ProcessControlBlock）实际上是个结构体\")]),t._v(\"中，即进程控制块 操作系统需要对各个并发运行的进程进行管理，\"),v(\"strong\",[t._v(\"但凡管理时所需要的信息，都会被放在PCB中\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"PCB是进程存在的唯 一标志，当进程被创 建时，操作系统为其 创建PCB，当进程结 束时，会回收其PCB。\")])]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025100830819.png\",alt:\"image-20231025100830819\"}})]),t._v(\" \"),v(\"p\",[t._v(\"进程的组成\")]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"PCB\")]),t._v(\" \"),v(\"li\",[t._v(\"程序段\")]),t._v(\" \"),v(\"li\",[t._v(\"数据段\")])]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025100934016.png\",alt:\"image-20231025100903226\"}})]),t._v(\" \"),v(\"p\",[t._v(\"一个程序开始运行前， 需要创建对应的进程， 也就要创建相应的PCB\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025100903226.png\",alt:\"image-20231025100934016\"}})]),t._v(\" \"),v(\"p\",[t._v(\"程序段、数据段、PCB三部分组成了进程实体（进程映像）\")]),t._v(\" \"),v(\"p\",[t._v(\"引入进程实体的概念后，可把\"),v(\"strong\",[t._v(\"进程定义为： 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。\")])]),t._v(\" \"),v(\"h2\",{attrs:{id:\"进程的状态转化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的状态转化\"}},[t._v(\"#\")]),t._v(\" 进程的状态转化\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025101553879.png\",alt:\"image-20231025101032858\"}})]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025101122161.png\",alt:\"image-20231025101122161\"}})]),t._v(\" \"),v(\"h3\",{attrs:{id:\"创建态-就绪态\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#创建态-就绪态\"}},[t._v(\"#\")]),t._v(\" 创建态 就绪态\")]),t._v(\" \"),v(\"p\",[t._v(\"进程\"),v(\"strong\",[t._v(\"正在被创建时，它的状态是“创建态”\")]),t._v(\"，在这个阶段操作系统会为进 程分配资源、初始化PCB\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"当进程创建完成后，便进入“就绪态”\")]),t._v(\"， 处于就绪态的进程已经具备运行条件， 但由于没有空闲CPU，就暂时不能运行\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"运行态-阻塞态\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#运行态-阻塞态\"}},[t._v(\"#\")]),t._v(\" 运行态 阻塞态\")]),t._v(\" \"),v(\"p\",[t._v(\"如果\"),v(\"strong\",[t._v(\"一个进程此时在CPU上运行，那么这个进程 处于“运行态”。\")]),t._v(\" CPU会执行该进程对应的程序（执行指令序列）\")]),t._v(\" \"),v(\"p\",[t._v(\"在进程运行的过程中，可能会\"),v(\"strong\",[t._v(\"请求等待某个事件的发生（如等待 某种系统资源的分配，或者等待其他进程的响应）\")]),t._v(\"。 在这个事件发生之前，\"),v(\"strong\",[t._v(\"进程无法继续往下执行\")]),t._v(\"，此时操作系统会 让这个\"),v(\"strong\",[t._v(\"进程下CPU\")]),t._v(\"，\"),v(\"strong\",[t._v(\"并让它进入“阻塞态”\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"当一个进程申请的资源被分配，或等待的事件发生，进程是由（阻塞态变回就绪态）\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"终止态\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#终止态\"}},[t._v(\"#\")]),t._v(\" 终止态\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"一个进程可以执行exit系统调用\")]),t._v(\"，\"),v(\"strong\",[t._v(\"请求操作系统终止该进程。 此时该进程会进入“终止态”\")]),t._v(\"，操作系统会让该进程\"),v(\"strong\",[t._v(\"下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB。 当终止进程的工作完成之后，这个进程就彻底消失了。\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程状态的转化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程状态的转化\"}},[t._v(\"#\")]),t._v(\" 进程状态的转化\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025101747249.png\",alt:\"image-20231025101553879\"}})]),t._v(\" \"),v(\"p\",[t._v(\"进程PCB中，\"),v(\"strong\",[t._v(\"会有一个变量state来表示进程的当前状态\")]),t._v(\"。如：1表示创建态、2表示就绪态、3表示运行态… 为了对同一个状态下的各个进程进行统一的管理，\"),v(\"strong\",[t._v(\"操作系统会将各个进程的PCB组织起来。\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程的连接方式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的连接方式\"}},[t._v(\"#\")]),t._v(\" 进程的连接方式\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"队列方式和索引方式\")])]),t._v(\" \"),v(\"p\",[t._v(\"每一种状态对应一个队列，一个队列有自己的指针\")]),t._v(\" \"),v(\"p\",[t._v(\"通常会把优先级高的进程放在队头\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025101032858.png\",alt:\"image-20231025101747249\"}})]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025101806663.png\",alt:\"image-20231025101806663\"}})]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025101838727.png\",alt:\"image-20231025101838727\"}})]),t._v(\" \"),v(\"h2\",{attrs:{id:\"进程控制\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程控制\"}},[t._v(\"#\")]),t._v(\" 进程控制\")]),t._v(\" \"),v(\"p\",[t._v(\"进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现 进程状态转换等功能。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"进程控制通过原语来实现\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"原语是一种特殊的程序， 它的执行具有原子性。\")])]),t._v(\" \"),v(\"p\",[t._v(\"如何实现原子性？\")]),t._v(\" \"),v(\"p\",[t._v(\"可以用\"),v(\"strong\",[t._v(\"关中断指令和开中断指令这两个特权指令实现原子性\")])]),t._v(\" \"),v(\"p\",[t._v(\"正常情况：\"),v(\"strong\",[t._v(\"CPU每执行完一条指令都会例 行检查是否有中断信号需要处理\")]),t._v(\"，如果有， 则暂停运行当前这段程序，转而执行相应的中断处理程序\")]),t._v(\" \"),v(\"p\",[t._v(\"CPU\"),v(\"strong\",[t._v(\"执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后 才会恢复检查。\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"这样，关中断、开中断之间的这些指令序 列就是不可被中断的，这就实现了“原子性”\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程的创建\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的创建\"}},[t._v(\"#\")]),t._v(\" 进程的创建\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025102859910.png\",alt:\"image-20231025103656653\"}})]),t._v(\" \"),v(\"ol\",[v(\"li\",[t._v(\"申请空白PCB\")]),t._v(\" \"),v(\"li\",[t._v(\"分配资源\")]),t._v(\" \"),v(\"li\",[t._v(\"初始化PCB\")]),t._v(\" \"),v(\"li\",[v(\"strong\",[t._v(\"将PCB插入就绪队列（就从创建态转化成了就绪态）\")])])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程的终止\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的终止\"}},[t._v(\"#\")]),t._v(\" 进程的终止\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025103007478.png\",alt:\"image-20231025102859910\"}})]),t._v(\" \"),v(\"ol\",[v(\"li\",[t._v(\"找到终止进程的PCB\")]),t._v(\" \"),v(\"li\",[t._v(\"进程下CPU\")]),t._v(\" \"),v(\"li\",[t._v(\"终止子进程\")]),t._v(\" \"),v(\"li\",[t._v(\"归还资源  给父进程（有父进程的话），没有就归还给操作系统\")]),t._v(\" \"),v(\"li\",[t._v(\"删除PCB\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程的阻塞与唤醒\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的阻塞与唤醒\"}},[t._v(\"#\")]),t._v(\" 进程的阻塞与唤醒\")]),t._v(\" \"),v(\"p\",[t._v(\"阻塞原语唤 醒原语必须 成对使用\")]),t._v(\" \"),v(\"p\",[t._v(\"因何事阻塞，就应由 何事唤醒\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025103656653.png\",alt:\"image-20231025104616348\"}})]),t._v(\" \"),v(\"p\",[t._v(\"阻塞：\")]),t._v(\" \"),v(\"ol\",[v(\"li\",[t._v(\"找到对应的PCB\")]),t._v(\" \"),v(\"li\",[t._v(\"保护现场，修改state状态\")]),t._v(\" \"),v(\"li\",[t._v(\"插入对应的队列\")])]),t._v(\" \"),v(\"p\",[t._v(\"唤醒：\")]),t._v(\" \"),v(\"ol\",[v(\"li\",[t._v(\"找到等待队列中对应的PCB\")]),t._v(\" \"),v(\"li\",[t._v(\"从阻塞队列中移除，将state设置为就绪态\")]),t._v(\" \"),v(\"li\",[t._v(\"插入就绪队列\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"进程的切换\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程的切换\"}},[t._v(\"#\")]),t._v(\" 进程的切换\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025103848077.png\",alt:\"image-20231025103007478\"}})]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025104616348.png\",alt:\"image-20231025103848077\"}})]),t._v(\" \"),v(\"p\",[t._v(\"保留现场的必要性：\")]),t._v(\" \"),v(\"p\",[t._v(\"CPU上有各种寄存器，比如说：\")]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"PC:程序计数 器，存放 下一条指令的地址\")]),t._v(\" \"),v(\"li\",[t._v(\"IR：指令寄存器， 存放当前正 在执行的指令\")]),t._v(\" \"),v(\"li\",[t._v(\"通用寄存器：存放其他必要的信息\")])]),t._v(\" \"),v(\"p\",[t._v(\"另一个进程在运 行过程中也会使用各个寄存器，数据就会丢失，所以要保留现场\")]),t._v(\" \"),v(\"p\",[t._v(\"解决办法：在进程切 换时先在PCB中保存这 个进程的运行环境 （保存一些必要的寄 存器信息），当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境\")]),t._v(\" \"),v(\"p\",[t._v(\"无论哪个进程控制原语，要做的无非三类事情：\")]),t._v(\" \"),v(\"ul\",[v(\"li\",[t._v(\"1.更新PCB中的信息\\n\"),v(\"ul\",[v(\"li\",[t._v(\"所有的进程控制原语一定都会\"),v(\"strong\",[t._v(\"修改进程状态标志\")])]),t._v(\" \"),v(\"li\",[t._v(\"剥夺当前运行进程的CPU使用权必然需要\"),v(\"strong\",[t._v(\"保存其运行环境\")])]),t._v(\" \"),v(\"li\",[t._v(\"某进程开始运行前必然要\"),v(\"strong\",[t._v(\"恢复期运行环境\")])])])]),t._v(\" \"),v(\"li\",[t._v(\"2.将\"),v(\"strong\",[t._v(\"PCB插入合适的队列\")])]),t._v(\" \"),v(\"li\",[t._v(\"3.分配/回收资源\")])]),t._v(\" \"),v(\"h2\",{attrs:{id:\"进程通信\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程通信\"}},[t._v(\"#\")]),t._v(\" 进程通信\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025104909329.png\",alt:\"image-20231025104909329\"}})]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"进程间通信（Inter-Process Communication，IPC）是指两个进程之间产生数据交互。\")])]),t._v(\" \"),v(\"p\",[t._v(\"进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的\"),v(\"strong\",[t._v(\"内存地址空间相互独立\")]),t._v(\".一个进程不能直接访问另 一个进程的地址空间。\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"共享存储\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#共享存储\"}},[t._v(\"#\")]),t._v(\" 共享存储\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025105056667.png\",alt:\"image-20231025105722505\"}})]),t._v(\" \"),v(\"p\",[t._v(\"进程之间共享一篇存储空间，但访问是互斥的。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"基于数据结构的共享\")]),t._v(\"：比如共享空间里\"),v(\"strong\",[t._v(\"只能放一个长度为10的数组。这种共享方式速度慢,限制多\")]),t._v(\",是一种低级通信方式\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"基于存储区的共享\")]),t._v(\"：操作系统在内存中划出一 块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式 速度很快，是一种高级通信方式。\")]),t._v(\" \"),v(\"h3\",{attrs:{id:\"消息传递\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#消息传递\"}},[t._v(\"#\")]),t._v(\" 消息传递\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"分为直接通信（消息发送进程要指明接收进程的ID）和间接通信。\")])]),t._v(\" \"),v(\"p\",[t._v(\"进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收 消息”两个原语进行数据交换。\")]),t._v(\" \"),v(\"h4\",{attrs:{id:\"直接通信\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#直接通信\"}},[t._v(\"#\")]),t._v(\" 直接通信\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025105752304.png\",alt:\"image-20231025105056667\"}})]),t._v(\" \"),v(\"h4\",{attrs:{id:\"间接通信\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#间接通信\"}},[t._v(\"#\")]),t._v(\" 间接通信\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025105722505.png\",alt:\"image-20231025105752304\"}})]),t._v(\" \"),v(\"p\",[t._v(\"间接通信方式，以“信箱”作为中间实体进行消息传递。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"并没有说明向哪个进程发消息\")])]),t._v(\" \"),v(\"p\",[t._v(\"可以多个进程往同一个信箱 send消息，也可以多个进程 从同一个信箱中receive消息\")]),t._v(\" \"),v(\"h4\",{attrs:{id:\"管道通信\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#管道通信\"}},[t._v(\"#\")]),t._v(\" 管道通信\")]),t._v(\" \"),v(\"p\",[t._v(\"“管道”是一个特殊的共享文 件，又名pipe文件。其实就是在 内存中开辟一个大小固定的内 存缓冲区\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"这个是先进先出的数据结构，与共享内存的方式不同，共享内存是可以随便在哪写在哪读\")])]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025105909114.png\",alt:\"image-20231025110648773\"}})]),t._v(\" \"),v(\"p\",[t._v(\"半双工通信：\"),v(\"strong\",[t._v(\"能同时从左往右，也能从右往左，但一个时刻只能从有一种方式\")])]),t._v(\" \"),v(\"p\",[t._v(\"1.管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置 两个管道。\")]),t._v(\" \"),v(\"p\",[t._v(\"2.各进程要互斥地访问管道（由操作系统实现）\")]),t._v(\" \"),v(\"p\",[t._v(\"3.\"),v(\"strong\",[t._v(\"当管道写满时，写进程将阻塞\")]),t._v(\"，直到读进程将管道中的数据取走，即可唤醒写进程。\")]),t._v(\" \"),v(\"p\",[t._v(\"4.\"),v(\"strong\",[t._v(\"当管道读空时，读进程将阻塞\")]),t._v(\"，直到写进程往管道中写入数据，即可唤醒读进程。\")]),t._v(\" \"),v(\"h2\",{attrs:{id:\"线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程\"}},[t._v(\"#\")]),t._v(\" 线程\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025110648773.png\",alt:\"image-20231025105909114\"}})]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025110745039.png\",alt:\"image-20231025111102575\"}})]),t._v(\" \"),v(\"p\",[t._v(\"有的进程可能需要“同时”做很多事，而传统 的进程只能串行地执行一系列程序。为此，引 入了“线程”，来增加并发度。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"引入线程后，线程成为了程序执行流的最小单位\")])]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"线程是一个基本的CPU执行单元， 也是程序执行流的最小单位\")]),t._v(\"。\")]),t._v(\" \"),v(\"p\",[t._v(\"引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了 系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ 视频、文字聊天、传文件）\")]),t._v(\" \"),v(\"p\",[t._v(\"引入线程后，\"),v(\"strong\",[t._v(\"进程只作为除CPU之 外的系统资源的分配单元\")]),t._v(\"（如打 印机、内存地址空间等都是分配 给进程的）。\")]),t._v(\" \"),v(\"p\",[v(\"strong\",[t._v(\"线程则作为处理机的分配单元。\")])]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025110905392.png\",alt:\"image-20231025110745039\"}})]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025110759247.png\",alt:\"image-20231025110759247\"}})]),t._v(\" \"),v(\"h3\",{attrs:{id:\"线程的实现方式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程的实现方式\"}},[t._v(\"#\")]),t._v(\" 线程的实现方式\")]),t._v(\" \"),v(\"h4\",{attrs:{id:\"用户级线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#用户级线程\"}},[t._v(\"#\")]),t._v(\" 用户级线程\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025111102575.png\",alt:\"image-20231025110905392\"}})]),t._v(\" \"),v(\"p\",[t._v(\"1.用户级线程由\"),v(\"strong\",[t._v(\"应用程序通过线程库实现\")]),t._v(\"， 所有的\"),v(\"strong\",[t._v(\"线程管理工作都由应用程序负责\")]),t._v(\"（包括线程切换）\")]),t._v(\" \"),v(\"p\",[t._v(\"2.用户级线程中，\"),v(\"strong\",[t._v(\"线程切换可以在用户态下即可完成，无需操作系统干预。\")])]),t._v(\" \"),v(\"p\",[t._v(\"3.在用户看来，是有多个线程。但是在\"),v(\"strong\",[t._v(\"操作系统内核看来，并意识不到线程的存在。 “用户级线程”就是“从用户视角看能看到 的线程”\")])]),t._v(\" \"),v(\"p\",[t._v(\"优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统 开销小，效率高\")]),t._v(\" \"),v(\"p\",[t._v(\"缺点：当\"),v(\"strong\",[t._v(\"一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可 在多核处理机上并行运行。\")])]),t._v(\" \"),v(\"h4\",{attrs:{id:\"内核级线程\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#内核级线程\"}},[t._v(\"#\")]),t._v(\" 内核级线程\")]),t._v(\" \"),v(\"p\",[t._v(\"内核级线程（Kernel-LevelThread,KLT,又称“内核支持的线程”），由操作系统支持的线程\")]),t._v(\" \"),v(\"p\",[t._v(\"1.内核级线程的\"),v(\"strong\",[t._v(\"管理工作由操作系统内核完成\")]),t._v(\"。\")]),t._v(\" \"),v(\"p\",[t._v(\"2.线程调度、切换等工作都由内核负责，因此\"),v(\"strong\",[t._v(\"内核级线程的切换必然需要在核心态下才能完成。\")])]),t._v(\" \"),v(\"p\",[t._v(\"3.操作系统会为每\"),v(\"strong\",[t._v(\"个内核级线程建立相应的 TCB（ThreadControlBlock，线程控制块）， 通过TCB对线程进行管理\")]),t._v(\"。“内核级线程”就 是“从操作系统内核视角看能看到的线程”\")]),t._v(\" \"),v(\"p\",[t._v(\"优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。\")]),t._v(\" \"),v(\"p\",[t._v(\"缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要\"),v(\"strong\",[t._v(\"切换到核心态，因此线程管理的成本高，开销大。\")])]),t._v(\" \"),v(\"h3\",{attrs:{id:\"多线程模型\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#多线程模型\"}},[t._v(\"#\")]),t._v(\" 多线程模型\")]),t._v(\" \"),v(\"p\",[t._v(\"一对一模型\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025112756397.png\",alt:\"image-20231025112726578\"}})]),t._v(\" \"),v(\"p\",[t._v(\"一对一模型：一个用户级线程映射到一个内 核级线程。每个用户进程有与用户级线程同 数量的内核级线程。\")]),t._v(\" \"),v(\"p\",[t._v(\"优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核 处理机上并行执行。\")]),t._v(\" \"),v(\"p\",[t._v(\"缺点：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到 核心态，因此线程管理的成本高，开销大。\")]),t._v(\" \"),v(\"p\",[t._v(\"多对一模型：\"),v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025112726578.png\",alt:\"image-20231025112756397\"}})]),t._v(\" \"),v(\"p\",[t._v(\"多对一模型：多个用户级线程映射到一个内 核级线程。且一个进程只被分配一个内核级 线程。\")]),t._v(\" \"),v(\"p\",[t._v(\"优点：用户级线程的切换在用户空间即可完 成，不需要切换到核心态，线程管理的系统 开销小，效率高\")]),t._v(\" \"),v(\"p\",[t._v(\"缺点：当一个用户级线程被阻塞后，整个进 程都会被阻塞，并发度不高。多个线程不可 在多核处理机上并行运行\")]),t._v(\" \"),v(\"p\",[t._v(\"多对多模型\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025113024103.png\",alt:\"image-20231025113054747\"}})]),t._v(\" \"),v(\"h3\",{attrs:{id:\"线程的状态转化\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程的状态转化\"}},[t._v(\"#\")]),t._v(\" 线程的状态转化\")]),t._v(\" \"),v(\"p\",[t._v(\"与进程类似\")]),t._v(\" \"),v(\"p\",[v(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231025113054747.png\",alt:\"image-20231025113024103\"}})])])}),[],!1,null,null,null);v.default=a.exports}}]);","extractedComments":[]}