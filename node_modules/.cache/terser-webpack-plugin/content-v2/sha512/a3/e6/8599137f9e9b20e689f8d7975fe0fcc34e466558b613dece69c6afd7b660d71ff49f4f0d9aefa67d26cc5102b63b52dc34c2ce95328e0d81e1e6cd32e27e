{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{457:function(v,_,t){\"use strict\";t.r(_);var s=t(4),r=Object(s.a)({},(function(){var v=this,_=v._self._c;return _(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[_(\"h1\",{attrs:{id:\"操作系统面试常考记录01\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#操作系统面试常考记录01\"}},[v._v(\"#\")]),v._v(\" 操作系统面试常考记录01\")]),v._v(\" \"),_(\"h2\",{attrs:{id:\"什么是操作系统\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是操作系统\"}},[v._v(\"#\")]),v._v(\" 什么是操作系统？\")]),v._v(\" \"),_(\"p\",[v._v(\"通过以下四点可以概括操作系统到底是什么：\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[v._v(\"操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。\")]),v._v(\" \"),_(\"li\",[v._v(\"操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。\")]),v._v(\" \"),_(\"li\",[v._v(\"操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。\")]),v._v(\" \"),_(\"li\",[v._v(\"操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\")])]),v._v(\" \"),_(\"p\",[v._v(\"很多人容易把操作系统的内核（Kernel）和中央处理器（CPU，Central Processing Unit）弄混。你可以简单从下面两点来区别：\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[v._v(\"操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。\")]),v._v(\" \"),_(\"li\",[v._v(\"CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。\")])]),v._v(\" \"),_(\"p\",[v._v(\"下图清晰说明了应用程序、内核、CPU 这三者的关系。\")]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231130204126653.png\",alt:\"image-20231130204126653\"}})]),v._v(\" \"),_(\"h2\",{attrs:{id:\"操作系统主要有哪些功能\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#操作系统主要有哪些功能\"}},[v._v(\"#\")]),v._v(\" 操作系统主要有哪些功能？\")]),v._v(\" \"),_(\"p\",[v._v(\"从资源管理的角度来看，操作系统有 6 大功能：\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"strong\",[v._v(\"进程和线程的管理\")]),v._v(\"：进程的创建、撤销、阻塞、唤醒，进程间的通信等。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"存储管理\")]),v._v(\"：内存的分配和管理、外存（磁盘等）的分配和管理等。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"文件管理\")]),v._v(\"：文件的读、写、创建及删除等。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"设备管理\")]),v._v(\"：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"网络管理\")]),v._v(\"：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"安全管理\")]),v._v(\"：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。\")])]),v._v(\" \"),_(\"h2\",{attrs:{id:\"什么是僵尸进程和孤儿进程\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是僵尸进程和孤儿进程\"}},[v._v(\"#\")]),v._v(\" 什么是僵尸进程和孤儿进程？\")]),v._v(\" \"),_(\"p\",[v._v(\"在 Unix/Linux 系统中，\"),_(\"strong\",[v._v(\"子进程通常是通过 fork()系统调用创建的\")]),v._v(\"，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。\")]),v._v(\" \"),_(\"p\",[v._v(\"当一个进程调用 exit()系统调用结束自己的生命时，内核会释放该进程的所有资源，包括打开的文件、占用的内存等，但是该进程对应的 PCB 依然存在于系统中。这些信息只有在父进程调用 wait()或 waitpid()系统调用时才会被释放，以便让父进程得到子进程的状态信息。\")]),v._v(\" \"),_(\"p\",[v._v(\"这样的设计可以让父进程在子进程结束时得到子进程的状态信息，并且可以防止出现“僵尸进程”（即子进程结束后 PCB 仍然存在但父进程无法得到状态信息的情况）。\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[v._v(\"僵尸进程\")]),v._v(\"：\"),_(\"strong\",[v._v(\"子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源\")]),v._v(\"，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"孤儿进程\")]),v._v(\"：\"),_(\"strong\",[v._v(\"一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程\")]),v._v(\"。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"如何查看是否有僵尸进程\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#如何查看是否有僵尸进程\"}},[v._v(\"#\")]),v._v(\" 如何查看是否有僵尸进程？\")]),v._v(\" \"),_(\"p\",[v._v(\"Linux 下可以使用 \"),_(\"strong\",[v._v(\"Top 命令查找，\"),_(\"code\",[v._v(\"zombie\")]),v._v(\" 值表示僵尸进程的数量，为 0 则代表没有僵尸进程。\")])]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231130204152410.png\",alt:\"image-20231130204139675\"}})]),v._v(\" \"),_(\"p\",[v._v(\"下面这个命令可以定位僵尸进程以及该僵尸进程的父进程：\")]),v._v(\" \"),_(\"div\",{staticClass:\"language-bash line-numbers-mode\"},[_(\"pre\",{pre:!0,attrs:{class:\"language-bash\"}},[_(\"code\",[_(\"span\",{pre:!0,attrs:{class:\"token function\"}},[v._v(\"ps\")]),v._v(\" \"),_(\"span\",{pre:!0,attrs:{class:\"token parameter variable\"}},[v._v(\"-A\")]),v._v(\" -ostat,ppid,pid,cmd \"),_(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[v._v(\"|\")]),_(\"span\",{pre:!0,attrs:{class:\"token function\"}},[v._v(\"grep\")]),v._v(\" \"),_(\"span\",{pre:!0,attrs:{class:\"token parameter variable\"}},[v._v(\"-e\")]),v._v(\" \"),_(\"span\",{pre:!0,attrs:{class:\"token string\"}},[v._v(\"'^[Zz]'\")]),v._v(\"\\n\")])]),v._v(\" \"),_(\"div\",{staticClass:\"line-numbers-wrapper\"},[_(\"span\",{staticClass:\"line-number\"},[v._v(\"1\")]),_(\"br\")])]),_(\"h2\",{attrs:{id:\"进程和线程的区别是什么\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程和线程的区别是什么\"}},[v._v(\"#\")]),v._v(\" 进程和线程的区别是什么？\")]),v._v(\" \"),_(\"p\",[v._v(\"下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！\")]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231130204209385.png\",alt:\"image-20231130204152410\"}})]),v._v(\" \"),_(\"p\",[v._v(\"从上图可以看出：一个进程中可以有多个线程，多个线程\"),_(\"strong\",[v._v(\"共享\")]),v._v(\"进程的\"),_(\"strong\",[v._v(\"堆\")]),v._v(\"和\"),_(\"strong\",[v._v(\"方法区 (JDK1.8 之后的元空间)\"),_(\"strong\",[v._v(\"资源，但是每个线程有自己的\")]),v._v(\"程序计数器\")]),v._v(\"、\"),_(\"strong\",[v._v(\"虚拟机栈\")]),v._v(\" 和 \"),_(\"strong\",[v._v(\"本地方法栈\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"总结：\")])]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[v._v(\"线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。\")])]),v._v(\" \"),_(\"li\",[v._v(\"线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"线程执行开销小，但不利于资源的管理和保护；而进程正相反。\")])])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"有了进程为什么还需要线程\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#有了进程为什么还需要线程\"}},[v._v(\"#\")]),v._v(\" 有了进程为什么还需要线程?\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[v._v(\"进程切换是一个开销很大的操作，线程切换的成本较低。\")])]),v._v(\" \"),_(\"li\",[v._v(\"线程更轻量，一个进程可以创建多个线程。\")]),v._v(\" \"),_(\"li\",[v._v(\"多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。\")]),v._v(\" \"),_(\"li\",[v._v(\"同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"为什么要使用多线程\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#为什么要使用多线程\"}},[v._v(\"#\")]),v._v(\" 为什么要使用多线程?\")]),v._v(\" \"),_(\"p\",[v._v(\"先从总体上来说：\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[v._v(\"从计算机底层来说：\")]),v._v(\" \"),_(\"strong\",[v._v(\"线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。\")])]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"从当代互联网发展趋势来说：\")]),v._v(\" 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"线程间的同步的方式有哪些\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程间的同步的方式有哪些\"}},[v._v(\"#\")]),v._v(\" 线程间的同步的方式有哪些？\")]),v._v(\" \"),_(\"p\",[v._v(\"线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。\")]),v._v(\" \"),_(\"p\",[v._v(\"下面是几种常见的线程同步的方式：\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"strong\",[v._v(\"互斥锁(Mutex)\")]),v._v(\"：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 \"),_(\"code\",[v._v(\"synchronized\")]),v._v(\" 关键词和各种 \"),_(\"code\",[v._v(\"Lock\")]),v._v(\" 都是这种机制。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"读写锁（Read-Write Lock）\")]),v._v(\"：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"信号量(Semaphore)\")]),v._v(\"：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"屏障（Barrier）\")]),v._v(\"：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 \"),_(\"code\",[v._v(\"CyclicBarrier\")]),v._v(\" 是这种机制。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"事件(Event)\")]),v._v(\" :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"pcb-是什么-包含哪些信息\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#pcb-是什么-包含哪些信息\"}},[v._v(\"#\")]),v._v(\" PCB 是什么？包含哪些信息？\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"PCB（Process Control Block）\")]),v._v(\" 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。\")]),v._v(\" \"),_(\"p\",[v._v(\"当操作系统创建一个新进程时，会为该进程分配一个唯一的进程 ID，并且为该进程创建一个对应的进程控制块。当进程执行时，PCB 中的信息会不断变化，操作系统会根据这些信息来管理和调度进程。\")]),v._v(\" \"),_(\"p\",[v._v(\"PCB 主要包含下面几部分的内容：\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[v._v(\"进程的描述信息，包括进程的名称、标识符等等；\")]),v._v(\" \"),_(\"li\",[v._v(\"进程的调度信息，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级（标识进程的重要程度）等等；\")]),v._v(\" \"),_(\"li\",[v._v(\"进程对资源的需求情况，包括 CPU 时间、内存空间、I/O 设备等等。\")]),v._v(\" \"),_(\"li\",[v._v(\"进程打开的文件信息，包括文件描述符、文件类型、打开模式等等。\")]),v._v(\" \"),_(\"li\",[v._v(\"处理机的状态信息（由处理机的各种寄存器中的内容组成的），包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针。\")]),v._v(\" \"),_(\"li\",[v._v(\"……\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"进程间的通信方式有哪些\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程间的通信方式有哪些\"}},[v._v(\"#\")]),v._v(\" 进程间的通信方式有哪些？\")]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"下面这部分总结参考了:\"),_(\"a\",{attrs:{href:\"https://www.jianshu.com/p/c1015f5ffa74\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"《进程间通信 IPC (InterProcess Communication)》\"),_(\"OutboundLink\")],1),v._v(\" 这篇文章，推荐阅读，总结的非常不错。\")])]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"strong\",[v._v(\"管道/匿名管道(Pipes)\")]),v._v(\"：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"有名管道(Named Pipes)\")]),v._v(\" : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 \"),_(\"strong\",[v._v(\"先进先出(First In First Out)\")]),v._v(\" 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"信号(Signal)\")]),v._v(\"：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"消息队列(Message Queuing)\")]),v._v(\"：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。\"),_(\"strong\",[v._v(\"消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。\")])]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"信号量(Semaphores)\")]),v._v(\"：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"共享内存(Shared memory)\")]),v._v(\"：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"套接字(Sockets)\")]),v._v(\" : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\")])]),v._v(\" \"),_(\"h2\",{attrs:{id:\"死锁\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁\"}},[v._v(\"#\")]),v._v(\" 死锁\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"什么是死锁\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是死锁\"}},[v._v(\"#\")]),v._v(\" 什么是死锁？\")]),v._v(\" \"),_(\"p\",[v._v(\"死锁（Deadlock）描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"能列举一个操作系统发生死锁的例子吗\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#能列举一个操作系统发生死锁的例子吗\"}},[v._v(\"#\")]),v._v(\" 能列举一个操作系统发生死锁的例子吗？\")]),v._v(\" \"),_(\"p\",[v._v(\"假设有两个进程 A 和 B，以及两个资源 X 和 Y，它们的分配情况如下：\")]),v._v(\" \"),_(\"table\",[_(\"thead\",[_(\"tr\",[_(\"th\",[v._v(\"进程\")]),v._v(\" \"),_(\"th\",[v._v(\"占用资源\")]),v._v(\" \"),_(\"th\",[v._v(\"需求资源\")])])]),v._v(\" \"),_(\"tbody\",[_(\"tr\",[_(\"td\",[v._v(\"A\")]),v._v(\" \"),_(\"td\",[v._v(\"X\")]),v._v(\" \"),_(\"td\",[v._v(\"Y\")])]),v._v(\" \"),_(\"tr\",[_(\"td\",[v._v(\"B\")]),v._v(\" \"),_(\"td\",[v._v(\"Y\")]),v._v(\" \"),_(\"td\",[v._v(\"X\")])])])]),v._v(\" \"),_(\"p\",[v._v(\"此时，进程 A 占用资源 X 并且请求资源 Y，而进程 B 已经占用了资源 Y 并请求资源 X。两个进程都在等待对方释放资源，无法继续执行，陷入了死锁状态。\")]),v._v(\" \"),_(\"h3\",{attrs:{id:\"产生死锁的四个必要条件是什么\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#产生死锁的四个必要条件是什么\"}},[v._v(\"#\")]),v._v(\" 产生死锁的四个必要条件是什么?\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"strong\",[v._v(\"互斥\")]),v._v(\"：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"占有并等待\")]),v._v(\"：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"非抢占\")]),v._v(\"：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"循环等待\")]),v._v(\"：有一组等待进程 \"),_(\"code\",[v._v(\"{P0, P1,..., Pn}\")]),v._v(\"， \"),_(\"code\",[v._v(\"P0\")]),v._v(\" 等待的资源被 \"),_(\"code\",[v._v(\"P1\")]),v._v(\" 占有，\"),_(\"code\",[v._v(\"P1\")]),v._v(\" 等待的资源被 \"),_(\"code\",[v._v(\"P2\")]),v._v(\" 占有，……，\"),_(\"code\",[v._v(\"Pn-1\")]),v._v(\" 等待的资源被 \"),_(\"code\",[v._v(\"Pn\")]),v._v(\" 占有，\"),_(\"code\",[v._v(\"Pn\")]),v._v(\" 等待的资源被 \"),_(\"code\",[v._v(\"P0\")]),v._v(\" 占有。\")])]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"注意 ⚠️\")]),v._v(\"：这四个条件是产生死锁的 \"),_(\"strong\",[v._v(\"必要条件\")]),v._v(\" ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。\")]),v._v(\" \"),_(\"p\",[v._v(\"下面是百度百科对必要条件的解释：\")]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"如果没有事物情况 A，则必然没有事物情况 B，也就是说如果有事物情况 B 则一定有事物情况 A，那么 A 就是 B 的必要条件。从逻辑学上看，B 能推导出 A，A 就是 B 的必要条件，等价于 B 是 A 的充分条件。\")])]),v._v(\" \"),_(\"h3\",{attrs:{id:\"解决死锁的方法\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#解决死锁的方法\"}},[v._v(\"#\")]),v._v(\" 解决死锁的方法\")]),v._v(\" \"),_(\"p\",[v._v(\"解决死锁的方法可以从多个角度去分析，一般的情况下，有\"),_(\"strong\",[v._v(\"预防，避免，检测和解除四种\")]),v._v(\"。\")]),v._v(\" \"),_(\"ul\",[_(\"li\",[_(\"strong\",[v._v(\"预防\")]),v._v(\" 是采用某种策略，\"),_(\"strong\",[v._v(\"限制并发进程对资源的请求\")]),v._v(\"，从而使得死锁的必要条件在系统执行的任何时间上都不满足。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"避免\")]),v._v(\"则是系统在分配资源时，根据资源的使用情况\"),_(\"strong\",[v._v(\"提前做出预测\")]),v._v(\"，从而\"),_(\"strong\",[v._v(\"避免死锁的发生\")])]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"检测\")]),v._v(\"是指系统设有\"),_(\"strong\",[v._v(\"专门的机构\")]),v._v(\"，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"解除\")]),v._v(\" 是与检测相配套的一种措施，用于\"),_(\"strong\",[v._v(\"将进程从死锁状态下解脱出来\")]),v._v(\"。\")])]),v._v(\" \"),_(\"h4\",{attrs:{id:\"死锁的预防\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁的预防\"}},[v._v(\"#\")]),v._v(\" 死锁的预防\")]),v._v(\" \"),_(\"p\",[v._v(\"死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。\")]),v._v(\" \"),_(\"p\",[v._v(\"破坏第一个条件 \"),_(\"strong\",[v._v(\"互斥条件\")]),v._v(\"：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 \"),_(\"strong\",[v._v(\"往往是不能同时访问的\")]),v._v(\" ，所以这种做法在大多数的场合是行不通的。\")]),v._v(\" \"),_(\"p\",[v._v(\"破坏第三个条件 \"),_(\"strong\",[v._v(\"非抢占\")]),v._v(\"：也就是说可以采用 \"),_(\"strong\",[v._v(\"剥夺式调度算法\")]),v._v(\"，但剥夺式调度方法目前一般仅适用于 \"),_(\"strong\",[v._v(\"主存资源\")]),v._v(\" 和 \"),_(\"strong\",[v._v(\"处理器资源\")]),v._v(\" 的分配，并不适用于所有的资源，会导致 \"),_(\"strong\",[v._v(\"资源利用率下降\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[v._v(\"所以一般比较实用的 \"),_(\"strong\",[v._v(\"预防死锁的方法\")]),v._v(\"，是通过考虑破坏第二个条件和第四个条件。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"1、静态分配策略\")])]),v._v(\" \"),_(\"p\",[v._v(\"静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。\")]),v._v(\" \"),_(\"p\",[v._v(\"静态分配策略逻辑简单，实现也很容易，但这种策略 \"),_(\"strong\",[v._v(\"严重地降低了资源利用率\")]),v._v(\"，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才使用的，这样就可能造成一个进程占有了一些 \"),_(\"strong\",[v._v(\"几乎不用的资源而使其他需要该资源的进程产生等待\")]),v._v(\" 的情况。\")]),v._v(\" \"),_(\"p\",[_(\"strong\",[v._v(\"2、层次分配策略\")])]),v._v(\" \"),_(\"p\",[v._v(\"层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。\")]),v._v(\" \"),_(\"h4\",{attrs:{id:\"死锁的避免\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁的避免\"}},[v._v(\"#\")]),v._v(\" 死锁的避免\")]),v._v(\" \"),_(\"p\",[v._v(\"上面提到的 \"),_(\"strong\",[v._v(\"破坏\")]),v._v(\" 死锁产生的四个必要条件之一就可以成功 \"),_(\"strong\",[v._v(\"预防系统发生死锁\")]),v._v(\" ，但是会导致 \"),_(\"strong\",[v._v(\"低效的进程运行\")]),v._v(\" 和 \"),_(\"strong\",[v._v(\"资源使用率\")]),v._v(\" 。而死锁的避免相反，它的角度是允许系统中\"),_(\"strong\",[v._v(\"同时存在四个必要条件\")]),v._v(\" ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 \"),_(\"strong\",[v._v(\"明智和合理的选择\")]),v._v(\" ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。\")]),v._v(\" \"),_(\"p\",[v._v(\"我们将系统的状态分为 \"),_(\"strong\",[v._v(\"安全状态\")]),v._v(\" 和 \"),_(\"strong\",[v._v(\"不安全状态\")]),v._v(\" ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\")]),v._v(\" \"),_(\"blockquote\",[_(\"p\",[v._v(\"如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。\")])]),v._v(\" \"),_(\"p\",[v._v(\"那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 \"),_(\"strong\",[v._v(\"避免死锁算法\")]),v._v(\" 就是 Dijkstra 的\"),_(\"strong\",[v._v(\"银行家算法\")]),v._v(\"，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，\"),_(\"strong\",[v._v(\"银行家算法\")]),v._v(\" 通过先 \"),_(\"strong\",[v._v(\"试探\")]),v._v(\" 分配给该进程资源，然后通过 \"),_(\"strong\",[v._v(\"安全性算法\")]),v._v(\" 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 \"),_(\"strong\",[v._v(\"真的分配资源给该进程\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[v._v(\"银行家算法详情可见：\"),_(\"a\",{attrs:{href:\"https://blog.csdn.net/qq_33414271/article/details/80245715\",target:\"_blank\",rel:\"noopener noreferrer\"}},[v._v(\"《一句话+一张图说清楚——银行家算法》\"),_(\"OutboundLink\")],1),v._v(\" 。\")]),v._v(\" \"),_(\"p\",[v._v(\"操作系统教程书中讲述的银行家算法也比较清晰，可以一看.\")]),v._v(\" \"),_(\"p\",[v._v(\"死锁的避免(银行家算法)改善了 \"),_(\"strong\",[v._v(\"资源使用率低的问题\")]),v._v(\" ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 \"),_(\"strong\",[v._v(\"安全性检查\")]),v._v(\" ，需要花费较多的时间。\")]),v._v(\" \"),_(\"h4\",{attrs:{id:\"死锁的检测\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁的检测\"}},[v._v(\"#\")]),v._v(\" 死锁的检测\")]),v._v(\" \"),_(\"p\",[v._v(\"对资源的分配加以限制可以 \"),_(\"strong\",[v._v(\"预防和避免\")]),v._v(\" 死锁的发生，但是都不利于各进程对系统资源的\"),_(\"strong\",[v._v(\"充分共享\")]),v._v(\"。解决死锁问题的另一条途径是 \"),_(\"strong\",[v._v(\"死锁检测和解除\")]),v._v(\" (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 \"),_(\"strong\",[v._v(\"乐观锁\")]),v._v(\" ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 \"),_(\"strong\",[v._v(\"死锁的预防和避免\")]),v._v(\" 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。\")]),v._v(\" \"),_(\"p\",[v._v(\"这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 \"),_(\"strong\",[v._v(\"定时地运行一个 “死锁检测”\")]),v._v(\" 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\")]),v._v(\" \"),_(\"h5\",{attrs:{id:\"进程-资源分配图\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#进程-资源分配图\"}},[v._v(\"#\")]),v._v(\" 进程-资源分配图\")]),v._v(\" \"),_(\"p\",[v._v(\"操作系统中的每一刻时刻的\"),_(\"strong\",[v._v(\"系统状态\")]),v._v(\"都可以用\"),_(\"strong\",[v._v(\"进程-资源分配图\")]),v._v(\"来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于\"),_(\"strong\",[v._v(\"检测系统是否处于死锁状态\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[v._v(\"用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 \"),_(\"strong\",[v._v(\"有向边\")]),v._v(\" 来表示\"),_(\"strong\",[v._v(\"进程申请资源和资源被分配的情况\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[v._v(\"图中 2-21 是\"),_(\"strong\",[v._v(\"进程-资源分配图\")]),v._v(\"的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 \"),_(\"strong\",[v._v(\"占有和等待资源的环路\")]),v._v(\" ，导致一组进程永远处于等待资源的状态，发生了 \"),_(\"strong\",[v._v(\"死锁\")]),v._v(\"。\")]),v._v(\" \"),_(\"p\",[_(\"img\",{attrs:{src:\"https://czynotebook.oss-cn-beijing.aliyuncs.com/notebook/image-20231130204139675.png\",alt:\"image-20231130204209385\"}})]),v._v(\" \"),_(\"p\",[v._v(\"进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。\")]),v._v(\" \"),_(\"h5\",{attrs:{id:\"死锁检测步骤\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁检测步骤\"}},[v._v(\"#\")]),v._v(\" 死锁检测步骤\")]),v._v(\" \"),_(\"p\",[v._v(\"知道了死锁检测的原理，我们可以利用下列步骤编写一个 \"),_(\"strong\",[v._v(\"死锁检测\")]),v._v(\" 程序，检测系统是否产生了死锁。\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"strong\",[v._v(\"如果进程-资源分配图中无环路，则此时系统没有发生死锁\")])]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。\")])]),v._v(\" \"),_(\"li\",[v._v(\"如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 \"),_(\"strong\",[v._v(\"既不阻塞又非独立的进程\")]),v._v(\" ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 \"),_(\"strong\",[v._v(\"消除所有的边\")]),v._v(\" ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 \"),_(\"strong\",[v._v(\"拓扑排序\")]),v._v(\")\")])]),v._v(\" \"),_(\"h4\",{attrs:{id:\"死锁的解除\"}},[_(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#死锁的解除\"}},[v._v(\"#\")]),v._v(\" 死锁的解除\")]),v._v(\" \"),_(\"p\",[v._v(\"当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：\")]),v._v(\" \"),_(\"ol\",[_(\"li\",[_(\"strong\",[v._v(\"立即结束所有进程的执行，重新启动操作系统\")]),v._v(\"：这种方法简单，但以前所在的工作全部作废，损失很大。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"撤销涉及死锁的所有进程，解除死锁后继续运行\")]),v._v(\"：这种方法能彻底打破\"),_(\"strong\",[v._v(\"死锁的循环等待\")]),v._v(\"条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。\")]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"逐个撤销涉及死锁的进程，回收其资源直至死锁解除。\")])]),v._v(\" \"),_(\"li\",[_(\"strong\",[v._v(\"抢占资源\")]),v._v(\"：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。\")])])])}),[],!1,null,null,null);_.default=r.exports}}]);","extractedComments":[]}